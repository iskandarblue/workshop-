var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import { PureComponent, createElement } from 'react';
import PropTypes from 'prop-types';
import autobind from '../utils/autobind';

import StaticMap from './static-map';
import { MAPBOX_LIMITS } from '../utils/map-state';
import WebMercatorViewport from 'viewport-mercator-project';

import TransitionManager from '../utils/transition-manager';

import { EventManager } from 'mjolnir.js';
import MapControls from '../utils/map-controls';
import config from '../config';
import deprecateWarn from '../utils/deprecate-warn';

var propTypes = Object.assign({}, StaticMap.propTypes, {
  // Additional props on top of StaticMap

  /** Viewport constraints */
  // Max zoom level
  maxZoom: PropTypes.number,
  // Min zoom level
  minZoom: PropTypes.number,
  // Max pitch in degrees
  maxPitch: PropTypes.number,
  // Min pitch in degrees
  minPitch: PropTypes.number,

  /**
   * `onViewportChange` callback is fired when the user interacted with the
   * map. The object passed to the callback contains viewport properties
   * such as `longitude`, `latitude`, `zoom` etc.
   */
  onViewportChange: PropTypes.func,

  /** Viewport transition **/
  // transition duration for viewport change
  transitionDuration: PropTypes.number,
  // TransitionInterpolator instance, can be used to perform custom transitions.
  transitionInterpolator: PropTypes.object,
  // type of interruption of current transition on update.
  transitionInterruption: PropTypes.number,
  // easing function
  transitionEasing: PropTypes.func,
  // transition status update functions
  onTransitionStart: PropTypes.func,
  onTransitionInterrupt: PropTypes.func,
  onTransitionEnd: PropTypes.func,

  /** Enables control event handling */
  // Scroll to zoom
  scrollZoom: PropTypes.bool,
  // Drag to pan
  dragPan: PropTypes.bool,
  // Drag to rotate
  dragRotate: PropTypes.bool,
  // Double click to zoom
  doubleClickZoom: PropTypes.bool,
  // Multitouch zoom
  touchZoom: PropTypes.bool,
  // Multitouch rotate
  touchRotate: PropTypes.bool,
  // Keyboard
  keyboard: PropTypes.bool,

  /**
     * Called when the map is hovered over.
     * @callback
     * @param {Object} event - The mouse event.
     * @param {[Number, Number]} event.lngLat - The coordinates of the pointer
     * @param {Array} event.features - The features under the pointer, using Mapbox's
     * queryRenderedFeatures API:
     * https://www.mapbox.com/mapbox-gl-js/api/#Map#queryRenderedFeatures
     * To make a layer interactive, set the `interactive` property in the
     * layer style to `true`. See Mapbox's style spec
     * https://www.mapbox.com/mapbox-gl-style-spec/#layer-interactive
     */
  onHover: PropTypes.func,
  /**
    * Called when the map is clicked.
    * @callback
    * @param {Object} event - The mouse event.
    * @param {[Number, Number]} event.lngLat - The coordinates of the pointer
    * @param {Array} event.features - The features under the pointer, using Mapbox's
    * queryRenderedFeatures API:
    * https://www.mapbox.com/mapbox-gl-js/api/#Map#queryRenderedFeatures
    * To make a layer interactive, set the `interactive` property in the
    * layer style to `true`. See Mapbox's style spec
    * https://www.mapbox.com/mapbox-gl-style-spec/#layer-interactive
    */
  onClick: PropTypes.func,

  /** Radius to detect features around a clicked point. Defaults to 0. */
  clickRadius: PropTypes.number,

  /** Accessor that returns a cursor style to show interactive state */
  getCursor: PropTypes.func,

  /** Advanced features */
  // Contraints for displaying the map. If not met, then the map is hidden.
  // Experimental! May be changed in minor version updates.
  visibilityConstraints: PropTypes.shape({
    minZoom: PropTypes.number,
    maxZoom: PropTypes.number,
    minPitch: PropTypes.number,
    maxPitch: PropTypes.number
  }),
  // A map control instance to replace the default map controls
  // The object must expose one property: `events` as an array of subscribed
  // event names; and two methods: `setState(state)` and `handle(event)`
  mapControls: PropTypes.shape({
    events: PropTypes.arrayOf(PropTypes.string),
    handleEvent: PropTypes.func
  })
});

var getDefaultCursor = function getDefaultCursor(_ref) {
  var isDragging = _ref.isDragging,
      isHovering = _ref.isHovering;
  return isDragging ? config.CURSOR.GRABBING : isHovering ? config.CURSOR.POINTER : config.CURSOR.GRAB;
};

var defaultProps = Object.assign({}, StaticMap.defaultProps, MAPBOX_LIMITS, TransitionManager.defaultProps, {
  onViewportChange: null,
  onClick: null,
  onHover: null,

  scrollZoom: true,
  dragPan: true,
  dragRotate: true,
  doubleClickZoom: true,

  clickRadius: 0,
  getCursor: getDefaultCursor,

  visibilityConstraints: MAPBOX_LIMITS
});

var childContextTypes = {
  viewport: PropTypes.instanceOf(WebMercatorViewport),
  isDragging: PropTypes.bool,
  eventManager: PropTypes.object
};

var InteractiveMap = function (_PureComponent) {
  _inherits(InteractiveMap, _PureComponent);

  _createClass(InteractiveMap, null, [{
    key: 'supported',
    value: function supported() {
      return StaticMap.supported();
    }
  }]);

  function InteractiveMap(props) {
    _classCallCheck(this, InteractiveMap);

    var _this = _possibleConstructorReturn(this, (InteractiveMap.__proto__ || Object.getPrototypeOf(InteractiveMap)).call(this, props));

    autobind(_this);
    // Check for deprecated props
    deprecateWarn(props);

    _this.state = {
      // Whether the cursor is down
      isDragging: false,
      // Whether the cursor is over a clickable feature
      isHovering: false
    };

    // If props.mapControls is not provided, fallback to default MapControls instance
    // Cannot use defaultProps here because it needs to be per map instance
    _this._mapControls = props.mapControls || new MapControls();

    _this._eventManager = new EventManager(null, { rightButton: true });
    return _this;
  }

  _createClass(InteractiveMap, [{
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        viewport: new WebMercatorViewport(this.props),
        isDragging: this.state.isDragging,
        eventManager: this._eventManager
      };
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var eventManager = this._eventManager;

      // Register additional event handlers for click and hover
      eventManager.on('mousemove', this._onMouseMove);
      eventManager.on('click', this._onMouseClick);

      this._mapControls.setOptions(Object.assign({}, this.props, {
        onStateChange: this._onInteractiveStateChange,
        eventManager: eventManager
      }));

      this._transitionManager = new TransitionManager(this.props);
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps) {
      this._mapControls.setOptions(nextProps);
      this._transitionManager.processViewportChange(nextProps);
    }
  }, {
    key: 'getMap',
    value: function getMap() {
      return this._map ? this._map.getMap() : null;
    }
  }, {
    key: 'queryRenderedFeatures',
    value: function queryRenderedFeatures(geometry, options) {
      return this._map.queryRenderedFeatures(geometry, options);
    }

    // Checks a visibilityConstraints object to see if the map should be displayed

  }, {
    key: '_checkVisibilityConstraints',
    value: function _checkVisibilityConstraints(props) {
      var capitalize = function capitalize(s) {
        return s[0].toUpperCase() + s.slice(1);
      };

      var visibilityConstraints = props.visibilityConstraints;

      for (var propName in props) {
        var capitalizedPropName = capitalize(propName);
        var minPropName = 'min' + capitalizedPropName;
        var maxPropName = 'max' + capitalizedPropName;

        if (minPropName in visibilityConstraints && props[propName] < visibilityConstraints[minPropName]) {
          return false;
        }
        if (maxPropName in visibilityConstraints && props[propName] > visibilityConstraints[maxPropName]) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: '_getFeatures',
    value: function _getFeatures(_ref2) {
      var pos = _ref2.pos,
          radius = _ref2.radius;

      var features = void 0;
      if (radius) {
        // Radius enables point features, like marker symbols, to be clicked.
        var size = radius;
        var bbox = [[pos[0] - size, pos[1] + size], [pos[0] + size, pos[1] - size]];
        features = this._map.queryRenderedFeatures(bbox);
      } else {
        features = this._map.queryRenderedFeatures(pos);
      }
      return features;
    }
  }, {
    key: '_onInteractiveStateChange',
    value: function _onInteractiveStateChange(_ref3) {
      var _ref3$isDragging = _ref3.isDragging,
          isDragging = _ref3$isDragging === undefined ? false : _ref3$isDragging;

      if (isDragging !== this.state.isDragging) {
        this.setState({ isDragging: isDragging });
      }
    }

    // HOVER AND CLICK

  }, {
    key: '_getPos',
    value: function _getPos(event) {
      var _event$offsetCenter = event.offsetCenter,
          x = _event$offsetCenter.x,
          y = _event$offsetCenter.y;

      return [x, y];
    }
  }, {
    key: '_onMouseMove',
    value: function _onMouseMove(event) {
      if (!this.state.isDragging) {
        var pos = this._getPos(event);
        var features = this._getFeatures({ pos: pos, radius: this.props.clickRadius });

        var isHovering = features && features.length > 0;
        if (isHovering !== this.state.isHovering) {
          this.setState({ isHovering: isHovering });
        }

        if (this.props.onHover) {
          var viewport = new WebMercatorViewport(this.props);
          event.lngLat = viewport.unproject(pos);
          event.features = features;

          this.props.onHover(event);
        }
      }
    }
  }, {
    key: '_onMouseClick',
    value: function _onMouseClick(event) {
      if (this.props.onClick) {
        var pos = this._getPos(event);
        var viewport = new WebMercatorViewport(this.props);
        event.lngLat = viewport.unproject(pos);
        event.features = this._getFeatures({ pos: pos, radius: this.props.clickRadius });

        this.props.onClick(event);
      }
    }
  }, {
    key: '_eventCanvasLoaded',
    value: function _eventCanvasLoaded(ref) {
      // This will be called with `null` after unmount, releasing event manager resource
      this._eventManager.setElement(ref);
    }
  }, {
    key: '_staticMapLoaded',
    value: function _staticMapLoaded(ref) {
      this._map = ref;
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          width = _props.width,
          height = _props.height,
          getCursor = _props.getCursor;


      var eventCanvasStyle = {
        width: width,
        height: height,
        position: 'relative',
        cursor: getCursor(this.state)
      };

      return createElement('div', {
        key: 'map-controls',
        ref: this._eventCanvasLoaded,
        style: eventCanvasStyle
      }, createElement(StaticMap, Object.assign({}, this.props, this._transitionManager && this._transitionManager.getViewportInTransition(), {
        visible: this._checkVisibilityConstraints(this.props),
        ref: this._staticMapLoaded,
        children: this.props.children
      })));
    }
  }]);

  return InteractiveMap;
}(PureComponent);

export default InteractiveMap;


InteractiveMap.displayName = 'InteractiveMap';
InteractiveMap.propTypes = propTypes;
InteractiveMap.defaultProps = defaultProps;
InteractiveMap.childContextTypes = childContextTypes;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21wb25lbnRzL2ludGVyYWN0aXZlLW1hcC5qcyJdLCJuYW1lcyI6WyJQdXJlQ29tcG9uZW50IiwiY3JlYXRlRWxlbWVudCIsIlByb3BUeXBlcyIsImF1dG9iaW5kIiwiU3RhdGljTWFwIiwiTUFQQk9YX0xJTUlUUyIsIldlYk1lcmNhdG9yVmlld3BvcnQiLCJUcmFuc2l0aW9uTWFuYWdlciIsIkV2ZW50TWFuYWdlciIsIk1hcENvbnRyb2xzIiwiY29uZmlnIiwiZGVwcmVjYXRlV2FybiIsInByb3BUeXBlcyIsIk9iamVjdCIsImFzc2lnbiIsIm1heFpvb20iLCJudW1iZXIiLCJtaW5ab29tIiwibWF4UGl0Y2giLCJtaW5QaXRjaCIsIm9uVmlld3BvcnRDaGFuZ2UiLCJmdW5jIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwidHJhbnNpdGlvbkludGVycG9sYXRvciIsIm9iamVjdCIsInRyYW5zaXRpb25JbnRlcnJ1cHRpb24iLCJ0cmFuc2l0aW9uRWFzaW5nIiwib25UcmFuc2l0aW9uU3RhcnQiLCJvblRyYW5zaXRpb25JbnRlcnJ1cHQiLCJvblRyYW5zaXRpb25FbmQiLCJzY3JvbGxab29tIiwiYm9vbCIsImRyYWdQYW4iLCJkcmFnUm90YXRlIiwiZG91YmxlQ2xpY2tab29tIiwidG91Y2hab29tIiwidG91Y2hSb3RhdGUiLCJrZXlib2FyZCIsIm9uSG92ZXIiLCJvbkNsaWNrIiwiY2xpY2tSYWRpdXMiLCJnZXRDdXJzb3IiLCJ2aXNpYmlsaXR5Q29uc3RyYWludHMiLCJzaGFwZSIsIm1hcENvbnRyb2xzIiwiZXZlbnRzIiwiYXJyYXlPZiIsInN0cmluZyIsImhhbmRsZUV2ZW50IiwiZ2V0RGVmYXVsdEN1cnNvciIsImlzRHJhZ2dpbmciLCJpc0hvdmVyaW5nIiwiQ1VSU09SIiwiR1JBQkJJTkciLCJQT0lOVEVSIiwiR1JBQiIsImRlZmF1bHRQcm9wcyIsImNoaWxkQ29udGV4dFR5cGVzIiwidmlld3BvcnQiLCJpbnN0YW5jZU9mIiwiZXZlbnRNYW5hZ2VyIiwiSW50ZXJhY3RpdmVNYXAiLCJzdXBwb3J0ZWQiLCJwcm9wcyIsInN0YXRlIiwiX21hcENvbnRyb2xzIiwiX2V2ZW50TWFuYWdlciIsInJpZ2h0QnV0dG9uIiwib24iLCJfb25Nb3VzZU1vdmUiLCJfb25Nb3VzZUNsaWNrIiwic2V0T3B0aW9ucyIsIm9uU3RhdGVDaGFuZ2UiLCJfb25JbnRlcmFjdGl2ZVN0YXRlQ2hhbmdlIiwiX3RyYW5zaXRpb25NYW5hZ2VyIiwibmV4dFByb3BzIiwicHJvY2Vzc1ZpZXdwb3J0Q2hhbmdlIiwiX21hcCIsImdldE1hcCIsImdlb21ldHJ5Iiwib3B0aW9ucyIsInF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyIsImNhcGl0YWxpemUiLCJzIiwidG9VcHBlckNhc2UiLCJzbGljZSIsInByb3BOYW1lIiwiY2FwaXRhbGl6ZWRQcm9wTmFtZSIsIm1pblByb3BOYW1lIiwibWF4UHJvcE5hbWUiLCJwb3MiLCJyYWRpdXMiLCJmZWF0dXJlcyIsInNpemUiLCJiYm94Iiwic2V0U3RhdGUiLCJldmVudCIsIm9mZnNldENlbnRlciIsIngiLCJ5IiwiX2dldFBvcyIsIl9nZXRGZWF0dXJlcyIsImxlbmd0aCIsImxuZ0xhdCIsInVucHJvamVjdCIsInJlZiIsInNldEVsZW1lbnQiLCJ3aWR0aCIsImhlaWdodCIsImV2ZW50Q2FudmFzU3R5bGUiLCJwb3NpdGlvbiIsImN1cnNvciIsImtleSIsIl9ldmVudENhbnZhc0xvYWRlZCIsInN0eWxlIiwiZ2V0Vmlld3BvcnRJblRyYW5zaXRpb24iLCJ2aXNpYmxlIiwiX2NoZWNrVmlzaWJpbGl0eUNvbnN0cmFpbnRzIiwiX3N0YXRpY01hcExvYWRlZCIsImNoaWxkcmVuIiwiZGlzcGxheU5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsU0FBUUEsYUFBUixFQUF1QkMsYUFBdkIsUUFBMkMsT0FBM0M7QUFDQSxPQUFPQyxTQUFQLE1BQXNCLFlBQXRCO0FBQ0EsT0FBT0MsUUFBUCxNQUFxQixtQkFBckI7O0FBRUEsT0FBT0Ms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ZSI6ImludGVyYWN0aXZlLW1hcC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7UHVyZUNvbXBvbmVudCwgY3JlYXRlRWxlbWVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBhdXRvYmluZCBmcm9tICcuLi91dGlscy9hdXRvYmluZCc7XG5cbmltcG9ydCBTdGF0aWNNYXAgZnJvbSAnLi9zdGF0aWMtbWFwJztcbmltcG9ydCB7TUFQQk9YX0xJTUlUU30gZnJvbSAnLi4vdXRpbHMvbWFwLXN0YXRlJztcbmltcG9ydCBXZWJNZXJjYXRvclZpZXdwb3J0IGZyb20gJ3ZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3QnO1xuXG5pbXBvcnQgVHJhbnNpdGlvbk1hbmFnZXIgZnJvbSAnLi4vdXRpbHMvdHJhbnNpdGlvbi1tYW5hZ2VyJztcblxuaW1wb3J0IHtFdmVudE1hbmFnZXJ9IGZyb20gJ21qb2xuaXIuanMnO1xuaW1wb3J0IE1hcENvbnRyb2xzIGZyb20gJy4uL3V0aWxzL21hcC1jb250cm9scyc7XG5pbXBvcnQgY29uZmlnIGZyb20gJy4uL2NvbmZpZyc7XG5pbXBvcnQgZGVwcmVjYXRlV2FybiBmcm9tICcuLi91dGlscy9kZXByZWNhdGUtd2Fybic7XG5cbmNvbnN0IHByb3BUeXBlcyA9IE9iamVjdC5hc3NpZ24oe30sIFN0YXRpY01hcC5wcm9wVHlwZXMsIHtcbiAgLy8gQWRkaXRpb25hbCBwcm9wcyBvbiB0b3Agb2YgU3RhdGljTWFwXG5cbiAgLyoqIFZpZXdwb3J0IGNvbnN0cmFpbnRzICovXG4gIC8vIE1heCB6b29tIGxldmVsXG4gIG1heFpvb206IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIE1pbiB6b29tIGxldmVsXG4gIG1pblpvb206IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIE1heCBwaXRjaCBpbiBkZWdyZWVzXG4gIG1heFBpdGNoOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBNaW4gcGl0Y2ggaW4gZGVncmVlc1xuICBtaW5QaXRjaDogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogYG9uVmlld3BvcnRDaGFuZ2VgIGNhbGxiYWNrIGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgaW50ZXJhY3RlZCB3aXRoIHRoZVxuICAgKiBtYXAuIFRoZSBvYmplY3QgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBjb250YWlucyB2aWV3cG9ydCBwcm9wZXJ0aWVzXG4gICAqIHN1Y2ggYXMgYGxvbmdpdHVkZWAsIGBsYXRpdHVkZWAsIGB6b29tYCBldGMuXG4gICAqL1xuICBvblZpZXdwb3J0Q2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKiogVmlld3BvcnQgdHJhbnNpdGlvbiAqKi9cbiAgLy8gdHJhbnNpdGlvbiBkdXJhdGlvbiBmb3Igdmlld3BvcnQgY2hhbmdlXG4gIHRyYW5zaXRpb25EdXJhdGlvbjogUHJvcFR5cGVzLm51bWJlcixcbiAgLy8gVHJhbnNpdGlvbkludGVycG9sYXRvciBpbnN0YW5jZSwgY2FuIGJlIHVzZWQgdG8gcGVyZm9ybSBjdXN0b20gdHJhbnNpdGlvbnMuXG4gIHRyYW5zaXRpb25JbnRlcnBvbGF0b3I6IFByb3BUeXBlcy5vYmplY3QsXG4gIC8vIHR5cGUgb2YgaW50ZXJydXB0aW9uIG9mIGN1cnJlbnQgdHJhbnNpdGlvbiBvbiB1cGRhdGUuXG4gIHRyYW5zaXRpb25JbnRlcnJ1cHRpb246IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIGVhc2luZyBmdW5jdGlvblxuICB0cmFuc2l0aW9uRWFzaW5nOiBQcm9wVHlwZXMuZnVuYyxcbiAgLy8gdHJhbnNpdGlvbiBzdGF0dXMgdXBkYXRlIGZ1bmN0aW9uc1xuICBvblRyYW5zaXRpb25TdGFydDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uVHJhbnNpdGlvbkludGVycnVwdDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uVHJhbnNpdGlvbkVuZDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqIEVuYWJsZXMgY29udHJvbCBldmVudCBoYW5kbGluZyAqL1xuICAvLyBTY3JvbGwgdG8gem9vbVxuICBzY3JvbGxab29tOiBQcm9wVHlwZXMuYm9vbCxcbiAgLy8gRHJhZyB0byBwYW5cbiAgZHJhZ1BhbjogUHJvcFR5cGVzLmJvb2wsXG4gIC8vIERyYWcgdG8gcm90YXRlXG4gIGRyYWdSb3RhdGU6IFByb3BUeXBlcy5ib29sLFxuICAvLyBEb3VibGUgY2xpY2sgdG8gem9vbVxuICBkb3VibGVDbGlja1pvb206IFByb3BUeXBlcy5ib29sLFxuICAvLyBNdWx0aXRvdWNoIHpvb21cbiAgdG91Y2hab29tOiBQcm9wVHlwZXMuYm9vbCxcbiAgLy8gTXVsdGl0b3VjaCByb3RhdGVcbiAgdG91Y2hSb3RhdGU6IFByb3BUeXBlcy5ib29sLFxuICAvLyBLZXlib2FyZFxuICBrZXlib2FyZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAvKipcbiAgICAqIENhbGxlZCB3aGVuIHRoZSBtYXAgaXMgaG92ZXJlZCBvdmVyLlxuICAgICogQGNhbGxiYWNrXG4gICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgbW91c2UgZXZlbnQuXG4gICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IGV2ZW50LmxuZ0xhdCAtIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnRlclxuICAgICogQHBhcmFtIHtBcnJheX0gZXZlbnQuZmVhdHVyZXMgLSBUaGUgZmVhdHVyZXMgdW5kZXIgdGhlIHBvaW50ZXIsIHVzaW5nIE1hcGJveCdzXG4gICAgKiBxdWVyeVJlbmRlcmVkRmVhdHVyZXMgQVBJOlxuICAgICogaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvYXBpLyNNYXAjcXVlcnlSZW5kZXJlZEZlYXR1cmVzXG4gICAgKiBUbyBtYWtlIGEgbGF5ZXIgaW50ZXJhY3RpdmUsIHNldCB0aGUgYGludGVyYWN0aXZlYCBwcm9wZXJ0eSBpbiB0aGVcbiAgICAqIGxheWVyIHN0eWxlIHRvIGB0cnVlYC4gU2VlIE1hcGJveCdzIHN0eWxlIHNwZWNcbiAgICAqIGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvI2xheWVyLWludGVyYWN0aXZlXG4gICAgKi9cbiAgb25Ib3ZlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIC8qKlxuICAgICogQ2FsbGVkIHdoZW4gdGhlIG1hcCBpcyBjbGlja2VkLlxuICAgICogQGNhbGxiYWNrXG4gICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgbW91c2UgZXZlbnQuXG4gICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IGV2ZW50LmxuZ0xhdCAtIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnRlclxuICAgICogQHBhcmFtIHtBcnJheX0gZXZlbnQuZmVhdHVyZXMgLSBUaGUgZmVhdHVyZXMgdW5kZXIgdGhlIHBvaW50ZXIsIHVzaW5nIE1hcGJveCdzXG4gICAgKiBxdWVyeVJlbmRlcmVkRmVhdHVyZXMgQVBJOlxuICAgICogaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvYXBpLyNNYXAjcXVlcnlSZW5kZXJlZEZlYXR1cmVzXG4gICAgKiBUbyBtYWtlIGEgbGF5ZXIgaW50ZXJhY3RpdmUsIHNldCB0aGUgYGludGVyYWN0aXZlYCBwcm9wZXJ0eSBpbiB0aGVcbiAgICAqIGxheWVyIHN0eWxlIHRvIGB0cnVlYC4gU2VlIE1hcGJveCdzIHN0eWxlIHNwZWNcbiAgICAqIGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvI2xheWVyLWludGVyYWN0aXZlXG4gICAgKi9cbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqIFJhZGl1cyB0byBkZXRlY3QgZmVhdHVyZXMgYXJvdW5kIGEgY2xpY2tlZCBwb2ludC4gRGVmYXVsdHMgdG8gMC4gKi9cbiAgY2xpY2tSYWRpdXM6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqIEFjY2Vzc29yIHRoYXQgcmV0dXJucyBhIGN1cnNvciBzdHlsZSB0byBzaG93IGludGVyYWN0aXZlIHN0YXRlICovXG4gIGdldEN1cnNvcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqIEFkdmFuY2VkIGZlYXR1cmVzICovXG4gIC8vIENvbnRyYWludHMgZm9yIGRpc3BsYXlpbmcgdGhlIG1hcC4gSWYgbm90IG1ldCwgdGhlbiB0aGUgbWFwIGlzIGhpZGRlbi5cbiAgLy8gRXhwZXJpbWVudGFsISBNYXkgYmUgY2hhbmdlZCBpbiBtaW5vciB2ZXJzaW9uIHVwZGF0ZXMuXG4gIHZpc2liaWxpdHlDb25zdHJhaW50czogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBtaW5ab29tOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIG1heFpvb206IFByb3BUeXBlcy5udW1iZXIsXG4gICAgbWluUGl0Y2g6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgbWF4UGl0Y2g6IFByb3BUeXBlcy5udW1iZXJcbiAgfSksXG4gIC8vIEEgbWFwIGNvbnRyb2wgaW5zdGFuY2UgdG8gcmVwbGFjZSB0aGUgZGVmYXVsdCBtYXAgY29udHJvbHNcbiAgLy8gVGhlIG9iamVjdCBtdXN0IGV4cG9zZSBvbmUgcHJvcGVydHk6IGBldmVudHNgIGFzIGFuIGFycmF5IG9mIHN1YnNjcmliZWRcbiAgLy8gZXZlbnQgbmFtZXM7IGFuZCB0d28gbWV0aG9kczogYHNldFN0YXRlKHN0YXRlKWAgYW5kIGBoYW5kbGUoZXZlbnQpYFxuICBtYXBDb250cm9sczogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBldmVudHM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLFxuICAgIGhhbmRsZUV2ZW50OiBQcm9wVHlwZXMuZnVuY1xuICB9KVxufSk7XG5cbmNvbnN0IGdldERlZmF1bHRDdXJzb3IgPSAoe2lzRHJhZ2dpbmcsIGlzSG92ZXJpbmd9KSA9PiBpc0RyYWdnaW5nID9cbiAgY29uZmlnLkNVUlNPUi5HUkFCQklORyA6XG4gIChpc0hvdmVyaW5nID8gY29uZmlnLkNVUlNPUi5QT0lOVEVSIDogY29uZmlnLkNVUlNPUi5HUkFCKTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSxcbiAgU3RhdGljTWFwLmRlZmF1bHRQcm9wcywgTUFQQk9YX0xJTUlUUywgVHJhbnNpdGlvbk1hbmFnZXIuZGVmYXVsdFByb3BzLFxuICB7XG4gICAgb25WaWV3cG9ydENoYW5nZTogbnVsbCxcbiAgICBvbkNsaWNrOiBudWxsLFxuICAgIG9uSG92ZXI6IG51bGwsXG5cbiAgICBzY3JvbGxab29tOiB0cnVlLFxuICAgIGRyYWdQYW46IHRydWUsXG4gICAgZHJhZ1JvdGF0ZTogdHJ1ZSxcbiAgICBkb3VibGVDbGlja1pvb206IHRydWUsXG5cbiAgICBjbGlja1JhZGl1czogMCxcbiAgICBnZXRDdXJzb3I6IGdldERlZmF1bHRDdXJzb3IsXG5cbiAgICB2aXNpYmlsaXR5Q29uc3RyYWludHM6IE1BUEJPWF9MSU1JVFNcbiAgfVxuKTtcblxuY29uc3QgY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gIHZpZXdwb3J0OiBQcm9wVHlwZXMuaW5zdGFuY2VPZihXZWJNZXJjYXRvclZpZXdwb3J0KSxcbiAgaXNEcmFnZ2luZzogUHJvcFR5cGVzLmJvb2wsXG4gIGV2ZW50TWFuYWdlcjogUHJvcFR5cGVzLm9iamVjdFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW50ZXJhY3RpdmVNYXAgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcblxuICBzdGF0aWMgc3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBTdGF0aWNNYXAuc3VwcG9ydGVkKCk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICBhdXRvYmluZCh0aGlzKTtcbiAgICAvLyBDaGVjayBmb3IgZGVwcmVjYXRlZCBwcm9wc1xuICAgIGRlcHJlY2F0ZVdhcm4ocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIC8vIFdoZXRoZXIgdGhlIGN1cnNvciBpcyBkb3duXG4gICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgIC8vIFdoZXRoZXIgdGhlIGN1cnNvciBpcyBvdmVyIGEgY2xpY2thYmxlIGZlYXR1cmVcbiAgICAgIGlzSG92ZXJpbmc6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIElmIHByb3BzLm1hcENvbnRyb2xzIGlzIG5vdCBwcm92aWRlZCwgZmFsbGJhY2sgdG8gZGVmYXVsdCBNYXBDb250cm9scyBpbnN0YW5jZVxuICAgIC8vIENhbm5vdCB1c2UgZGVmYXVsdFByb3BzIGhlcmUgYmVjYXVzZSBpdCBuZWVkcyB0byBiZSBwZXIgbWFwIGluc3RhbmNlXG4gICAgdGhpcy5fbWFwQ29udHJvbHMgPSBwcm9wcy5tYXBDb250cm9scyB8fCBuZXcgTWFwQ29udHJvbHMoKTtcblxuICAgIHRoaXMuX2V2ZW50TWFuYWdlciA9IG5ldyBFdmVudE1hbmFnZXIobnVsbCwge3JpZ2h0QnV0dG9uOiB0cnVlfSk7XG4gIH1cblxuICBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZpZXdwb3J0OiBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh0aGlzLnByb3BzKSxcbiAgICAgIGlzRHJhZ2dpbmc6IHRoaXMuc3RhdGUuaXNEcmFnZ2luZyxcbiAgICAgIGV2ZW50TWFuYWdlcjogdGhpcy5fZXZlbnRNYW5hZ2VyXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IGV2ZW50TWFuYWdlciA9IHRoaXMuX2V2ZW50TWFuYWdlcjtcblxuICAgIC8vIFJlZ2lzdGVyIGFkZGl0aW9uYWwgZXZlbnQgaGFuZGxlcnMgZm9yIGNsaWNrIGFuZCBob3ZlclxuICAgIGV2ZW50TWFuYWdlci5vbignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUpO1xuICAgIGV2ZW50TWFuYWdlci5vbignY2xpY2snLCB0aGlzLl9vbk1vdXNlQ2xpY2spO1xuXG4gICAgdGhpcy5fbWFwQ29udHJvbHMuc2V0T3B0aW9ucyhPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICBvblN0YXRlQ2hhbmdlOiB0aGlzLl9vbkludGVyYWN0aXZlU3RhdGVDaGFuZ2UsXG4gICAgICBldmVudE1hbmFnZXJcbiAgICB9KSk7XG5cbiAgICB0aGlzLl90cmFuc2l0aW9uTWFuYWdlciA9IG5ldyBUcmFuc2l0aW9uTWFuYWdlcih0aGlzLnByb3BzKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgdGhpcy5fbWFwQ29udHJvbHMuc2V0T3B0aW9ucyhuZXh0UHJvcHMpO1xuICAgIHRoaXMuX3RyYW5zaXRpb25NYW5hZ2VyLnByb2Nlc3NWaWV3cG9ydENoYW5nZShuZXh0UHJvcHMpO1xuICB9XG5cbiAgZ2V0TWFwKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAgPyB0aGlzLl9tYXAuZ2V0TWFwKCkgOiBudWxsO1xuICB9XG5cbiAgcXVlcnlSZW5kZXJlZEZlYXR1cmVzKGdlb21ldHJ5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5xdWVyeVJlbmRlcmVkRmVhdHVyZXMoZ2VvbWV0cnksIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gQ2hlY2tzIGEgdmlzaWJpbGl0eUNvbnN0cmFpbnRzIG9iamVjdCB0byBzZWUgaWYgdGhlIG1hcCBzaG91bGQgYmUgZGlzcGxheWVkXG4gIF9jaGVja1Zpc2liaWxpdHlDb25zdHJhaW50cyhwcm9wcykge1xuICAgIGNvbnN0IGNhcGl0YWxpemUgPSBzID0+IHNbMF0udG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSk7XG5cbiAgICBjb25zdCB7dmlzaWJpbGl0eUNvbnN0cmFpbnRzfSA9IHByb3BzO1xuICAgIGZvciAoY29uc3QgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgIGNvbnN0IGNhcGl0YWxpemVkUHJvcE5hbWUgPSBjYXBpdGFsaXplKHByb3BOYW1lKTtcbiAgICAgIGNvbnN0IG1pblByb3BOYW1lID0gYG1pbiR7Y2FwaXRhbGl6ZWRQcm9wTmFtZX1gO1xuICAgICAgY29uc3QgbWF4UHJvcE5hbWUgPSBgbWF4JHtjYXBpdGFsaXplZFByb3BOYW1lfWA7XG5cbiAgICAgIGlmIChtaW5Qcm9wTmFtZSBpbiB2aXNpYmlsaXR5Q29uc3RyYWludHMgJiZcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdIDwgdmlzaWJpbGl0eUNvbnN0cmFpbnRzW21pblByb3BOYW1lXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAobWF4UHJvcE5hbWUgaW4gdmlzaWJpbGl0eUNvbnN0cmFpbnRzICYmXG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA+IHZpc2liaWxpdHlDb25zdHJhaW50c1ttYXhQcm9wTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIF9nZXRGZWF0dXJlcyh7cG9zLCByYWRpdXN9KSB7XG4gICAgbGV0IGZlYXR1cmVzO1xuICAgIGlmIChyYWRpdXMpIHtcbiAgICAgIC8vIFJhZGl1cyBlbmFibGVzIHBvaW50IGZlYXR1cmVzLCBsaWtlIG1hcmtlciBzeW1ib2xzLCB0byBiZSBjbGlja2VkLlxuICAgICAgY29uc3Qgc2l6ZSA9IHJhZGl1cztcbiAgICAgIGNvbnN0IGJib3ggPSBbW3Bvc1swXSAtIHNpemUsIHBvc1sxXSArIHNpemVdLCBbcG9zWzBdICsgc2l6ZSwgcG9zWzFdIC0gc2l6ZV1dO1xuICAgICAgZmVhdHVyZXMgPSB0aGlzLl9tYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKGJib3gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmZWF0dXJlcyA9IHRoaXMuX21hcC5xdWVyeVJlbmRlcmVkRmVhdHVyZXMocG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xuICB9XG5cbiAgX29uSW50ZXJhY3RpdmVTdGF0ZUNoYW5nZSh7aXNEcmFnZ2luZyA9IGZhbHNlfSkge1xuICAgIGlmIChpc0RyYWdnaW5nICE9PSB0aGlzLnN0YXRlLmlzRHJhZ2dpbmcpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe2lzRHJhZ2dpbmd9KTtcbiAgICB9XG4gIH1cblxuICAvLyBIT1ZFUiBBTkQgQ0xJQ0tcbiAgX2dldFBvcyhldmVudCkge1xuICAgIGNvbnN0IHtvZmZzZXRDZW50ZXI6IHt4LCB5fX0gPSBldmVudDtcbiAgICByZXR1cm4gW3gsIHldO1xuICB9XG5cbiAgX29uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLmlzRHJhZ2dpbmcpIHtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuX2dldFBvcyhldmVudCk7XG4gICAgICBjb25zdCBmZWF0dXJlcyA9IHRoaXMuX2dldEZlYXR1cmVzKHtwb3MsIHJhZGl1czogdGhpcy5wcm9wcy5jbGlja1JhZGl1c30pO1xuXG4gICAgICBjb25zdCBpc0hvdmVyaW5nID0gZmVhdHVyZXMgJiYgZmVhdHVyZXMubGVuZ3RoID4gMDtcbiAgICAgIGlmIChpc0hvdmVyaW5nICE9PSB0aGlzLnN0YXRlLmlzSG92ZXJpbmcpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7aXNIb3ZlcmluZ30pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wcm9wcy5vbkhvdmVyKSB7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQodGhpcy5wcm9wcyk7XG4gICAgICAgIGV2ZW50LmxuZ0xhdCA9IHZpZXdwb3J0LnVucHJvamVjdChwb3MpO1xuICAgICAgICBldmVudC5mZWF0dXJlcyA9IGZlYXR1cmVzO1xuXG4gICAgICAgIHRoaXMucHJvcHMub25Ib3ZlcihldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX29uTW91c2VDbGljayhldmVudCkge1xuICAgIGlmICh0aGlzLnByb3BzLm9uQ2xpY2spIHtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuX2dldFBvcyhldmVudCk7XG4gICAgICBjb25zdCB2aWV3cG9ydCA9IG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KHRoaXMucHJvcHMpO1xuICAgICAgZXZlbnQubG5nTGF0ID0gdmlld3BvcnQudW5wcm9qZWN0KHBvcyk7XG4gICAgICBldmVudC5mZWF0dXJlcyA9IHRoaXMuX2dldEZlYXR1cmVzKHtwb3MsIHJhZGl1czogdGhpcy5wcm9wcy5jbGlja1JhZGl1c30pO1xuXG4gICAgICB0aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIF9ldmVudENhbnZhc0xvYWRlZChyZWYpIHtcbiAgICAvLyBUaGlzIHdpbGwgYmUgY2FsbGVkIHdpdGggYG51bGxgIGFmdGVyIHVubW91bnQsIHJlbGVhc2luZyBldmVudCBtYW5hZ2VyIHJlc291cmNlXG4gICAgdGhpcy5fZXZlbnRNYW5hZ2VyLnNldEVsZW1lbnQocmVmKTtcbiAgfVxuXG4gIF9zdGF0aWNNYXBMb2FkZWQocmVmKSB7XG4gICAgdGhpcy5fbWFwID0gcmVmO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0LCBnZXRDdXJzb3J9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IGV2ZW50Q2FudmFzU3R5bGUgPSB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgY3Vyc29yOiBnZXRDdXJzb3IodGhpcy5zdGF0ZSlcbiAgICB9O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAga2V5OiAnbWFwLWNvbnRyb2xzJyxcbiAgICAgICAgcmVmOiB0aGlzLl9ldmVudENhbnZhc0xvYWRlZCxcbiAgICAgICAgc3R5bGU6IGV2ZW50Q2FudmFzU3R5bGVcbiAgICAgIH0sXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQoU3RhdGljTWFwLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLFxuICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25NYW5hZ2VyICYmIHRoaXMuX3RyYW5zaXRpb25NYW5hZ2VyLmdldFZpZXdwb3J0SW5UcmFuc2l0aW9uKCksXG4gICAgICAgICAge1xuICAgICAgICAgICAgdmlzaWJsZTogdGhpcy5fY2hlY2tWaXNpYmlsaXR5Q29uc3RyYWludHModGhpcy5wcm9wcyksXG4gICAgICAgICAgICByZWY6IHRoaXMuX3N0YXRpY01hcExvYWRlZCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgfVxuICAgICAgICApKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn1cblxuSW50ZXJhY3RpdmVNYXAuZGlzcGxheU5hbWUgPSAnSW50ZXJhY3RpdmVNYXAnO1xuSW50ZXJhY3RpdmVNYXAucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuSW50ZXJhY3RpdmVNYXAuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuSW50ZXJhY3RpdmVNYXAuY2hpbGRDb250ZXh0VHlwZXMgPSBjaGlsZENvbnRleHRUeXBlcztcbiJdfQ==