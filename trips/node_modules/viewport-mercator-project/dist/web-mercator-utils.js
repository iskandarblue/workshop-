'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); // TODO - THE UTILITIES IN THIS FILE SHOULD BE IMPORTED FROM WEB-MERCATOR-VIEWPORT MODULE

exports.zoomToScale = zoomToScale;
exports.scaleToZoom = scaleToZoom;
exports.lngLatToWorld = lngLatToWorld;
exports.worldToLngLat = worldToLngLat;
exports.getMeterZoom = getMeterZoom;
exports.getDistanceScales = getDistanceScales;
exports.getWorldPosition = getWorldPosition;
exports.getViewMatrix = getViewMatrix;
exports.getProjectionMatrix = getProjectionMatrix;
exports.worldToPixels = worldToPixels;
exports.pixelsToWorld = pixelsToWorld;

var _math = require('math.gl');

var _mathUtils = require('./math-utils');

var _perspective = require('gl-mat4/perspective');

var _perspective2 = _interopRequireDefault(_perspective);

var _scale = require('gl-mat4/scale');

var _scale2 = _interopRequireDefault(_scale);

var _translate = require('gl-mat4/translate');

var _translate2 = _interopRequireDefault(_translate);

var _rotateX = require('gl-mat4/rotateX');

var _rotateX2 = _interopRequireDefault(_rotateX);

var _rotateZ = require('gl-mat4/rotateZ');

var _rotateZ2 = _interopRequireDefault(_rotateZ);

var _lerp = require('gl-vec2/lerp');

var _lerp2 = _interopRequireDefault(_lerp);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// CONSTANTS
var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS = PI / 180;
var RADIANS_TO_DEGREES = 180 / PI;
var TILE_SIZE = 512;
// Average circumference (40075 km equatorial, 40007 km meridional)
var EARTH_CIRCUMFERENCE = 40.03e6;

/** Util functions **/
function zoomToScale(zoom) {
  return Math.pow(2, zoom);
}

function scaleToZoom(scale) {
  return Math.log2(scale);
}

/**
 * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
 * Performs the nonlinear part of the web mercator projection.
 * Remaining projection is done with 4x4 matrices which also handles
 * perspective.
 *
 * @param {Array} lngLat - [lng, lat] coordinates
 *   Specifies a point on the sphere to project onto the map.
 * @return {Array} [x,y] coordinates.
 */
function lngLatToWorld(_ref, scale) {
  var _ref2 = _slicedToArray(_ref, 2),
      lng = _ref2[0],
      lat = _ref2[1];

  scale *= TILE_SIZE;
  var lambda2 = lng * DEGREES_TO_RADIANS;
  var phi2 = lat * DEGREES_TO_RADIANS;
  var x = scale * (lambda2 + PI) / (2 * PI);
  var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x, y];
}

/**
 * Unproject world point [x,y] on map onto {lat, lon} on sphere
 *
 * @param {object|Vector} xy - object with {x,y} members
 *  representing point on projected map plane
 * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
 *   Has toArray method if you need a GeoJSON Array.
 *   Per cartographic tradition, lat and lon are specified as degrees.
 */
function worldToLngLat(_ref3, scale) {
  var _ref4 = _slicedToArray(_ref3, 2),
      x = _ref4[0],
      y = _ref4[1];

  scale *= TILE_SIZE;
  var lambda2 = x / scale * (2 * PI) - PI;
  var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale * (2 * PI))) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
}

// Returns the zoom level that gives a 1 meter pixel at a certain latitude
// S=C*cos(y)/2^(z+8)
function getMeterZoom(_ref5) {
  var latitude = _ref5.latitude;

  (0, _assert2.default)(latitude);
  var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
  return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 8;
}

/**
 * Calculate distance scales in meters around current lat/lon, both for
 * degrees and pixels.
 * In mercator projection mode, the distance scales vary significantly
 * with latitude.
 */
function getDistanceScales(_ref6) {
  var latitude = _ref6.latitude,
      longitude = _ref6.longitude,
      zoom = _ref6.zoom,
      scale = _ref6.scale,
      _ref6$highPrecision = _ref6.highPrecision,
      highPrecision = _ref6$highPrecision === undefined ? false : _ref6$highPrecision;

  // Calculate scale from zoom if not provided
  scale = scale !== undefined ? scale : zoomToScale(zoom);

  (0, _assert2.default)(isFinite(latitude) && isFinite(longitude) && isFinite(scale));

  var result = {};
  var worldSize = TILE_SIZE * scale;
  var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);

  /**
   * Number of pixels occupied by one degree longitude around current lat/lon:
     pixelsPerDegreeX = d(lngLatToWorld([lng, lat])[0])/d(lng)
       = scale * TILE_SIZE * DEGREES_TO_RADIANS / (2 * PI)
     pixelsPerDegreeY = d(lngLatToWorld([lng, lat])[1])/d(lat)
       = -scale * TILE_SIZE * DEGREES_TO_RADIANS / cos(lat * DEGREES_TO_RADIANS)  / (2 * PI)
   */
  var pixelsPerDegreeX = worldSize / 360;
  var pixelsPerDegreeY = pixelsPerDegreeX / latCosine;

  /**
   * Number of pixels occupied by one meter around current lat/lon:
   */
  var altPixelsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;

  result.pixelsPerMeter = [altPixelsPerMeter, altPixelsPerMeter, altPixelsPerMeter];
  result.metersPerPixel = [1 / altPixelsPerMeter, 1 / altPixelsPerMeter, 1 / altPixelsPerMeter];

  result.pixelsPerDegree = [pixelsPerDegreeX, pixelsPerDegreeY, altPixelsPerMeter];
  result.degreesPerPixel = [1 / pixelsPerDegreeX, 1 / pixelsPerDegreeY, 1 / altPixelsPerMeter];

  /**
   * Taylor series 2nd order for 1/latCosine
     f'(a) * (x - a)
       = d(1/cos(lat * DEGREES_TO_RADIANS))/d(lat) * dLat
       = DEGREES_TO_RADIANS * tan(lat * DEGREES_TO_RADIANS) / cos(lat * DEGREES_TO_RADIANS) * dLat
   */
  if (highPrecision) {
    var latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;
    var pixelsPerDegreeY2 = pixelsPerDegreeX * latCosine2 / 2;
    var altPixelsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
    var altPixelsPerMeter2 = altPixelsPerDegree2 / pixelsPerDegreeY * altPixelsPerMeter;

    result.pixelsPerDegree2 = [0, pixelsPerDegreeY2, altPixelsPerDegree2];
    result.pixelsPerMeter2 = [altPixelsPerMeter2, 0, altPixelsPerMeter2];
  }

  // Main results, used for converting meters to latlng deltas and scaling offsets
  return result;
}

/**
 * Calculates a mercator world position ("pixels" in given zoom level)
 * from a lng/lat and meterOffset
 */
function getWorldPosition(_ref7) {
  var longitude = _ref7.longitude,
      latitude = _ref7.latitude,
      zoom = _ref7.zoom,
      scale = _ref7.scale,
      meterOffset = _ref7.meterOffset,
      _ref7$distanceScales = _ref7.distanceScales,
      distanceScales = _ref7$distanceScales === undefined ? null : _ref7$distanceScales;

  // Calculate scale from zoom if not provided
  scale = scale !== undefined ? scale : zoomToScale(zoom);

  // Make a centered version of the matrix for projection modes without an offset
  var center2d = lngLatToWorld([longitude, latitude], scale);
  var center = new _math.Vector3(center2d[0], center2d[1], 0);

  if (meterOffset) {
    // Calculate distance scales if lng/lat/zoom are provided
    distanceScales = distanceScales || getDistanceScales({ latitude: latitude, longitude: longitude, scale: scale });

    var pixelPosition = new _math.Vector3(meterOffset)
    // Convert to pixels in current zoom
    .scale(distanceScales.pixelsPerMeter)
    // We want positive Y to represent an offset towards north,
    // but web mercator world coordinates is top-left
    .scale([1, -1, 1]);
    center.add(pixelPosition);
  }

  return center;
}

// ATTRIBUTION:
// view and projection matrix creation is intentionally kept compatible with
// mapbox-gl's implementation to ensure that seamless interoperation
// with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js

// Variable fov (in radians)
function getFov(_ref8) {
  var height = _ref8.height,
      altitude = _ref8.altitude;

  return 2 * Math.atan(height / 2 / altitude);
}

function getClippingPlanes(_ref9) {
  var altitude = _ref9.altitude,
      pitch = _ref9.pitch;

  // Find the distance from the center point to the center top
  // in altitude units using law of sines.
  var pitchRadians = pitch * DEGREES_TO_RADIANS;
  var halfFov = Math.atan(0.5 / altitude);
  var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov);

  // Calculate z value of the farthest fragment that should be rendered.
  var farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;

  return { farZ: farZ, nearZ: 0.1 };
}

function getViewMatrix(_ref10) {
  var height = _ref10.height,
      pitch = _ref10.pitch,
      bearing = _ref10.bearing,
      altitude = _ref10.altitude,
      _ref10$center = _ref10.center,
      center = _ref10$center === undefined ? null : _ref10$center,
      _ref10$flipY = _ref10.flipY,
      flipY = _ref10$flipY === undefined ? false : _ref10$flipY;


  // VIEW MATRIX: PROJECTS MERCATOR WORLD COORDINATES
  // Note that mercator world coordinates typically need to be flipped
  //
  // Note: As usual, matrix operation orders should be read in reverse
  // since vectors will be multiplied from the right during transformation
  var vm = (0, _mathUtils.createMat4)();

  // Move camera to altitude (along the pitch & bearing direction)
  (0, _translate2.default)(vm, vm, [0, 0, -altitude]);

  // After the rotateX, z values are in pixel units. Convert them to
  // altitude units. 1 altitude unit = the screen height.
  (0, _scale2.default)(vm, vm, [1, 1, 1 / height]);

  // Rotate by bearing, and then by pitch (which tilts the view)
  (0, _rotateX2.default)(vm, vm, -pitch * DEGREES_TO_RADIANS);
  (0, _rotateZ2.default)(vm, vm, bearing * DEGREES_TO_RADIANS);

  if (flipY) {
    (0, _scale2.default)(vm, vm, [1, -1, 1]);
  }

  if (center) {
    (0, _translate2.default)(vm, vm, new _math.Vector3(center).negate());
  }

  return vm;
}

// PROJECTION MATRIX: PROJECTS FROM CAMERA (VIEW) SPACE TO CLIPSPACE
// This is a "Mapbox" projection matrix - matches mapbox exactly if farZMultiplier === 1
function getProjectionMatrix(_ref11) {
  var width = _ref11.width,
      height = _ref11.height,
      pitch = _ref11.pitch,
      altitude = _ref11.altitude,
      _ref11$farZMultiplier = _ref11.farZMultiplier,
      farZMultiplier = _ref11$farZMultiplier === undefined ? 10 : _ref11$farZMultiplier;

  var _getClippingPlanes = getClippingPlanes({ altitude: altitude, pitch: pitch }),
      nearZ = _getClippingPlanes.nearZ,
      farZ = _getClippingPlanes.farZ;

  var fov = getFov({ height: height, altitude: altitude });

  var projectionMatrix = (0, _perspective2.default)([], fov, // fov in radians
  width / height, // aspect ratio
  nearZ, // near plane
  farZ * farZMultiplier // far plane
  );

  return projectionMatrix;
}

/**
 * Project flat coordinates to pixels on screen.
 *
 * @param {Array} xyz - flat coordinate on 512*512 Mercator Zoom 0 tile
 * @param {Matrix4} pixelProjectionMatrix - projection matrix
 * @return {Array} [x, y, depth] pixel coordinate on screen.
 */
function worldToPixels(xyz, pixelProjectionMatrix) {
  var _xyz = _slicedToArray(xyz, 3),
      x = _xyz[0],
      y = _xyz[1],
      _xyz$ = _xyz[2],
      z = _xyz$ === undefined ? 0 : _xyz$;

  (0, _assert2.default)(isFinite(x) && isFinite(y) && isFinite(z));

  return (0, _mathUtils.transformVector)(pixelProjectionMatrix, [x, y, z, 1]);
}

/**
 * Unproject pixels on screen to flat coordinates.
 *
 * @param {Array} xyz - pixel coordinate on screen.
 * @param {Matrix4} pixelUnprojectionMatrix - unprojection matrix
 * @param {Number} targetZ - if pixel coordinate does not have a 3rd component (depth),
 *    targetZ is used as the elevation plane to unproject onto
 * @return {Array} [x, y, Z] flat coordinates on 512*512 Mercator Zoom 0 tile.
 */
function pixelsToWorld(xyz, pixelUnprojectionMatrix) {
  var targetZ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  var _xyz2 = _slicedToArray(xyz, 3),
      x = _xyz2[0],
      y = _xyz2[1],
      z = _xyz2[2];

  (0, _assert2.default)(isFinite(x) && isFinite(y));

  if (Number.isFinite(z)) {
    // Has depth component
    var coord = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, z, 1]);
    return coord;
  }

  // since we don't know the correct projected z value for the point,
  // unproject two points to get a line and then find the point on that line with z=0
  var coord0 = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, 0, 1]);
  var coord1 = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, 1, 1]);

  var z0 = coord0[2];
  var z1 = coord1[2];

  var t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
  return (0, _lerp2.default)([], coord0, coord1, t);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy93ZWItbWVyY2F0b3ItdXRpbHMuanMiXSwibmFtZXMiOlsiem9vbVRvU2NhbGUiLCJzY2FsZVRvWm9vbSIsImxuZ0xhdFRvV29ybGQiLCJ3b3JsZFRvTG5nTGF0IiwiZ2V0TWV0ZXJab29tIiwiZ2V0RGlzdGFuY2VTY2FsZXMiLCJnZXRXb3JsZFBvc2l0aW9uIiwiZ2V0Vmlld01hdHJpeCIsImdldFByb2plY3Rpb25NYXRyaXgiLCJ3b3JsZFRvUGl4ZWxzIiwicGl4ZWxzVG9Xb3JsZCIsIlBJIiwiTWF0aCIsIlBJXzQiLCJERUdSRUVTX1RPX1JBRElBTlMiLCJSQURJQU5TX1RPX0RFR1JFRVMiLCJUSUxFX1NJWkUiLCJFQVJUSF9DSVJDVU1GRVJFTkNFIiwiem9vbSIsInBvdyIsInNjYWxlIiwibG9nMiIsImxuZyIsImxhdCIsImxhbWJkYTIiLCJwaGkyIiwieCIsInkiLCJsb2ciLCJ0YW4iLCJhdGFuIiwiZXhwIiwibGF0aXR1ZGUiLCJsYXRDb3NpbmUiLCJjb3MiLCJsb25naXR1ZGUiLCJoaWdoUHJlY2lzaW9uIiwidW5kZWZpbmVkIiwiaXNGaW5pdGUiLCJyZXN1bHQiLCJ3b3JsZFNpemUiLCJwaXhlbHNQZXJEZWdyZWVYIiwicGl4ZWxzUGVyRGVncmVlWSIsImFsdFBpeGVsc1Blck1ldGVyIiwicGl4ZWxzUGVyTWV0ZXIiLCJtZXRlcnNQZXJQaXhlbCIsInBpeGVsc1BlckRlZ3JlZSIsImRlZ3JlZXNQZXJQaXhlbCIsImxhdENvc2luZTIiLCJwaXhlbHNQZXJEZWdyZWVZMiIsImFsdFBpeGVsc1BlckRlZ3JlZTIiLCJhbHRQaXhlbHNQZXJNZXRlcjIiLCJwaXhlbHNQZXJEZWdyZWUyIiwicGl4ZWxzUGVyTWV0ZXIyIiwibWV0ZXJPZmZzZXQiLCJkaXN0YW5jZVNjYWxlcyIsImNlbnRlcjJkIiwiY2VudGVyIiwicGl4ZWxQb3NpdGlvbiIsImFkZCIsImdldEZvdiIsImhlaWdodCIsImFsdGl0dWRlIiwiZ2V0Q2xpcHBpbmdQbGFuZXMiLCJwaXRjaCIsInBpdGNoUmFkaWFucyIsImhhbGZGb3YiLCJ0b3BIYWxmU3VyZmFjZURpc3RhbmNlIiwic2luIiwiZmFyWiIsIm5lYXJaIiwiYmVhcmluZyIsImZsaXBZIiwidm0iLCJuZWdhdGUiLCJ3aWR0aCIsImZhclpNdWx0aXBsaWVyIiwiZm92IiwicHJvamVjdGlvbk1hdHJpeCIsInh5eiIsInBpeGVsUHJvamVjdGlvbk1hdHJpeCIsInoiLCJwaXhlbFVucHJvamVjdGlvbk1hdHJpeCIsInRhcmdldFoiLCJOdW1iZXIiLCJjb29yZCIsImNvb3JkMCIsImNvb3JkMSIsInowIiwiejEiLCJ0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7eXBCQUFBOztRQXVCZ0JBLFcsR0FBQUEsVztRQUlBQyxXLEdBQUFBLFc7UUFjQUMsYSxHQUFBQSxhO1FBa0JBQyxhLEdBQUFBLGE7UUFTQUMsWSxHQUFBQSxZO1FBWUFDLGlCLEdBQUFBLGlCO1FBdURBQyxnQixHQUFBQSxnQjtRQXVEQUMsYSxHQUFBQSxhO1FBMkNBQyxtQixHQUFBQSxtQjtRQTRCQUMsYSxHQUFBQSxhO1FBZ0JBQyxhLEdBQUFBLGE7O0FBblJoQjs7QUFDQTs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUE7QUFDQSxJQUFNQyxLQUFLQyxLQUFLRCxFQUFoQjtBQUNBLElBQU1FLE9BQU9GLEtBQUssQ0FBbEI7QUFDQSxJQUFNRyxxQkFBcUJILEtBQUssR0FBaEM7QUFDQSxJQUFNSSxxQkFBcUIsTUFBTUosRUFBakM7QUFDQSxJQUFNSyxZQUFZLEdBQWxCO0FBQ0E7QUFDQSxJQUFNQyxzQkFBc0IsT0FBNUI7O0FBRUE7QUFDTyxTQUFTakIsV0FBVCxDQUFxQmtCLElBQXJCLEVBQTJCO0FBQ2hDLFNBQU9OLEtBQUtPLEdBQUwsQ0FBUyxDQUFULEVBQVlELElBQVosQ0FBUDtBQUNEOztBQUVNLFNBQVNqQixXQUFULENBQXFCbUIsS0FBckIsRUFBNEI7QUFDakMsU0FBT1IsS0FBS1MsSUFBTCxDQUFVRCxLQUFWLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7OztBQVVPLFNBQVNsQixhQUFULE9BQW1Da0IsS0FBbkMsRUFBMEM7QUFBQTtBQUFBLE1BQWxCRSxHQUFrQjtBQUFBLE1BQWJDLEdBQWE7O0FBQy9DSCxXQUFTSixTQUFUO0FBQ0EsTUFBTVEsVUFBVUYsTUFBTVIsa0JBQXRCO0FBQ0EsTUFBTVcsT0FBT0YsTUFBTVQsa0JBQW5CO0FBQ0EsTUFBTVksSUFBSU4sU0FBU0ksVUFBVWIsRUFBbkIsS0FBMEIsSUFBSUEsRUFBOUIsQ0FBVjtBQUNBLE1BQU1nQixJQUFJUCxTQUFTVCxLQUFLQyxLQUFLZ0IsR0FBTCxDQUFTaEIsS0FBS2lCLEdBQUwsQ0FBU2hCLE9BQU9ZLE9BQU8sR0FBdkIsQ0FBVCxDQUFkLEtBQXdELElBQUlkLEVBQTVELENBQVY7QUFDQSxTQUFPLENBQUNlLENBQUQsRUFBSUMsQ0FBSixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNPLFNBQVN4QixhQUFULFFBQStCaUIsS0FBL0IsRUFBc0M7QUFBQTtBQUFBLE1BQWRNLENBQWM7QUFBQSxNQUFYQyxDQUFXOztBQUMzQ1AsV0FBU0osU0FBVDtBQUNBLE1BQU1RLFVBQVdFLElBQUlOLEtBQUwsSUFBZSxJQUFJVCxFQUFuQixJQUF5QkEsRUFBekM7QUFDQSxNQUFNYyxPQUFPLEtBQUtiLEtBQUtrQixJQUFMLENBQVVsQixLQUFLbUIsR0FBTCxDQUFTcEIsS0FBTWdCLElBQUlQLEtBQUwsSUFBZSxJQUFJVCxFQUFuQixDQUFkLENBQVYsSUFBbURFLElBQXhELENBQWI7QUFDQSxTQUFPLENBQUNXLFVBQVVULGtCQUFYLEVBQStCVSxPQUFPVixrQkFBdEMsQ0FBUDtBQUNEOztBQUVEO0FBQ0E7QUFDTyxTQUFTWCxZQUFULFFBQWtDO0FBQUEsTUFBWDRCLFFBQVcsU0FBWEEsUUFBVzs7QUFDdkMsd0JBQU9BLFFBQVA7QUFDQSxNQUFNQyxZQUFZckIsS0FBS3NCLEdBQUwsQ0FBU0YsV0FBV2xCLGtCQUFwQixDQUFsQjtBQUNBLFNBQU9iLFlBQVlnQixzQkFBc0JnQixTQUFsQyxJQUErQyxDQUF0RDtBQUNEOztBQUVEOzs7Ozs7QUFNTyxTQUFTNUIsaUJBQVQsUUFBc0Y7QUFBQSxNQUExRDJCLFFBQTBELFNBQTFEQSxRQUEwRDtBQUFBLE1BQWhERyxTQUFnRCxTQUFoREEsU0FBZ0Q7QUFBQSxNQUFyQ2pCLElBQXFDLFNBQXJDQSxJQUFxQztBQUFBLE1BQS9CRSxLQUErQixTQUEvQkEsS0FBK0I7QUFBQSxrQ0FBeEJnQixhQUF3QjtBQUFBLE1BQXhCQSxhQUF3Qix1Q0FBUixLQUFROztBQUMzRjtBQUNBaEIsVUFBUUEsVUFBVWlCLFNBQVYsR0FBc0JqQixLQUF0QixHQUE4QnBCLFlBQVlrQixJQUFaLENBQXRDOztBQUVBLHdCQUFPb0IsU0FBU04sUUFBVCxLQUFzQk0sU0FBU0gsU0FBVCxDQUF0QixJQUE2Q0csU0FBU2xCLEtBQVQsQ0FBcEQ7O0FBRUEsTUFBTW1CLFNBQVMsRUFBZjtBQUNBLE1BQU1DLFlBQVl4QixZQUFZSSxLQUE5QjtBQUNBLE1BQU1hLFlBQVlyQixLQUFLc0IsR0FBTCxDQUFTRixXQUFXbEIsa0JBQXBCLENBQWxCOztBQUVBOzs7Ozs7O0FBT0EsTUFBTTJCLG1CQUFtQkQsWUFBWSxHQUFyQztBQUNBLE1BQU1FLG1CQUFtQkQsbUJBQW1CUixTQUE1Qzs7QUFFQTs7O0FBR0EsTUFBTVUsb0JBQW9CSCxZQUFZdkIsbUJBQVosR0FBa0NnQixTQUE1RDs7QUFFQU0sU0FBT0ssY0FBUCxHQUF3QixDQUFDRCxpQkFBRCxFQUFvQkEsaUJBQXBCLEVBQXVDQSxpQkFBdkMsQ0FBeEI7QUFDQUosU0FBT00sY0FBUCxHQUF3QixDQUFDLElBQUlGLGlCQUFMLEVBQXdCLElBQUlBLGlCQUE1QixFQUErQyxJQUFJQSxpQkFBbkQsQ0FBeEI7O0FBRUFKLFNBQU9PLGVBQVAsR0FBeUIsQ0FBQ0wsZ0JBQUQsRUFBbUJDLGdCQUFuQixFQUFxQ0MsaUJBQXJDLENBQXpCO0FBQ0FKLFNBQU9RLGVBQVAsR0FBeUIsQ0FBQyxJQUFJTixnQkFBTCxFQUF1QixJQUFJQyxnQkFBM0IsRUFBNkMsSUFBSUMsaUJBQWpELENBQXpCOztBQUVBOzs7Ozs7QUFNQSxNQUFJUCxhQUFKLEVBQW1CO0FBQ2pCLFFBQU1ZLGFBQWFsQyxxQkFBcUJGLEtBQUtpQixHQUFMLENBQVNHLFdBQVdsQixrQkFBcEIsQ0FBckIsR0FBK0RtQixTQUFsRjtBQUNBLFFBQU1nQixvQkFBb0JSLG1CQUFtQk8sVUFBbkIsR0FBZ0MsQ0FBMUQ7QUFDQSxRQUFNRSxzQkFBc0JWLFlBQVl2QixtQkFBWixHQUFrQytCLFVBQTlEO0FBQ0EsUUFBTUcscUJBQXFCRCxzQkFBc0JSLGdCQUF0QixHQUF5Q0MsaUJBQXBFOztBQUVBSixXQUFPYSxnQkFBUCxHQUEwQixDQUFDLENBQUQsRUFBSUgsaUJBQUosRUFBdUJDLG1CQUF2QixDQUExQjtBQUNBWCxXQUFPYyxlQUFQLEdBQXlCLENBQUNGLGtCQUFELEVBQXFCLENBQXJCLEVBQXdCQSxrQkFBeEIsQ0FBekI7QUFDRDs7QUFFRDtBQUNBLFNBQU9aLE1BQVA7QUFDRDs7QUFFRDs7OztBQUlPLFNBQVNqQyxnQkFBVCxRQU9KO0FBQUEsTUFORDZCLFNBTUMsU0FOREEsU0FNQztBQUFBLE1BTERILFFBS0MsU0FMREEsUUFLQztBQUFBLE1BSkRkLElBSUMsU0FKREEsSUFJQztBQUFBLE1BSERFLEtBR0MsU0FIREEsS0FHQztBQUFBLE1BRkRrQyxXQUVDLFNBRkRBLFdBRUM7QUFBQSxtQ0FEREMsY0FDQztBQUFBLE1BRERBLGNBQ0Msd0NBRGdCLElBQ2hCOztBQUNEO0FBQ0FuQyxVQUFRQSxVQUFVaUIsU0FBVixHQUFzQmpCLEtBQXRCLEdBQThCcEIsWUFBWWtCLElBQVosQ0FBdEM7O0FBRUE7QUFDQSxNQUFNc0MsV0FBV3RELGNBQWMsQ0FBQ2lDLFNBQUQsRUFBWUgsUUFBWixDQUFkLEVBQXFDWixLQUFyQyxDQUFqQjtBQUNBLE1BQU1xQyxTQUFTLGtCQUFZRCxTQUFTLENBQVQsQ0FBWixFQUF5QkEsU0FBUyxDQUFULENBQXpCLEVBQXNDLENBQXRDLENBQWY7O0FBRUEsTUFBSUYsV0FBSixFQUFpQjtBQUNmO0FBQ0FDLHFCQUFpQkEsa0JBQWtCbEQsa0JBQWtCLEVBQUMyQixrQkFBRCxFQUFXRyxvQkFBWCxFQUFzQmYsWUFBdEIsRUFBbEIsQ0FBbkM7O0FBRUEsUUFBTXNDLGdCQUFnQixrQkFBWUosV0FBWjtBQUNwQjtBQURvQixLQUVuQmxDLEtBRm1CLENBRWJtQyxlQUFlWCxjQUZGO0FBR3BCO0FBQ0E7QUFKb0IsS0FLbkJ4QixLQUxtQixDQUtiLENBQUMsQ0FBRCxFQUFJLENBQUMsQ0FBTCxFQUFRLENBQVIsQ0FMYSxDQUF0QjtBQU1BcUMsV0FBT0UsR0FBUCxDQUFXRCxhQUFYO0FBQ0Q7O0FBRUQsU0FBT0QsTUFBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBU0csTUFBVCxRQUFvQztBQUFBLE1BQW5CQyxNQUFtQixTQUFuQkEsTUFBbUI7QUFBQSxNQUFYQyxRQUFXLFNBQVhBLFFBQVc7O0FBQ2xDLFNBQU8sSUFBSWxELEtBQUtrQixJQUFMLENBQVcrQixTQUFTLENBQVYsR0FBZUMsUUFBekIsQ0FBWDtBQUNEOztBQUVELFNBQVNDLGlCQUFULFFBQThDO0FBQUEsTUFBbEJELFFBQWtCLFNBQWxCQSxRQUFrQjtBQUFBLE1BQVJFLEtBQVEsU0FBUkEsS0FBUTs7QUFDNUM7QUFDQTtBQUNBLE1BQU1DLGVBQWVELFFBQVFsRCxrQkFBN0I7QUFDQSxNQUFNb0QsVUFBVXRELEtBQUtrQixJQUFMLENBQVUsTUFBTWdDLFFBQWhCLENBQWhCO0FBQ0EsTUFBTUsseUJBQ0p2RCxLQUFLd0QsR0FBTCxDQUFTRixPQUFULElBQW9CSixRQUFwQixHQUErQmxELEtBQUt3RCxHQUFMLENBQVN4RCxLQUFLRCxFQUFMLEdBQVUsQ0FBVixHQUFjc0QsWUFBZCxHQUE2QkMsT0FBdEMsQ0FEakM7O0FBR0E7QUFDQSxNQUFNRyxPQUFPekQsS0FBS3NCLEdBQUwsQ0FBU3RCLEtBQUtELEVBQUwsR0FBVSxDQUFWLEdBQWNzRCxZQUF2QixJQUF1Q0Usc0JBQXZDLEdBQWdFTCxRQUE3RTs7QUFFQSxTQUFPLEVBQUNPLFVBQUQsRUFBT0MsT0FBTyxHQUFkLEVBQVA7QUFDRDs7QUFFTSxTQUFTL0QsYUFBVCxTQVVKO0FBQUEsTUFSRHNELE1BUUMsVUFSREEsTUFRQztBQUFBLE1BUERHLEtBT0MsVUFQREEsS0FPQztBQUFBLE1BTkRPLE9BTUMsVUFOREEsT0FNQztBQUFBLE1BTERULFFBS0MsVUFMREEsUUFLQztBQUFBLDZCQUhETCxNQUdDO0FBQUEsTUFIREEsTUFHQyxpQ0FIUSxJQUdSO0FBQUEsNEJBRERlLEtBQ0M7QUFBQSxNQUREQSxLQUNDLGdDQURPLEtBQ1A7OztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxLQUFLLDRCQUFYOztBQUVBO0FBQ0EsMkJBQWVBLEVBQWYsRUFBbUJBLEVBQW5CLEVBQXVCLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFDWCxRQUFSLENBQXZCOztBQUVBO0FBQ0E7QUFDQSx1QkFBV1csRUFBWCxFQUFlQSxFQUFmLEVBQW1CLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxJQUFJWixNQUFYLENBQW5COztBQUVBO0FBQ0EseUJBQWFZLEVBQWIsRUFBaUJBLEVBQWpCLEVBQXFCLENBQUNULEtBQUQsR0FBU2xELGtCQUE5QjtBQUNBLHlCQUFhMkQsRUFBYixFQUFpQkEsRUFBakIsRUFBcUJGLFVBQVV6RCxrQkFBL0I7O0FBRUEsTUFBSTBELEtBQUosRUFBVztBQUNULHlCQUFXQyxFQUFYLEVBQWVBLEVBQWYsRUFBbUIsQ0FBQyxDQUFELEVBQUksQ0FBQyxDQUFMLEVBQVEsQ0FBUixDQUFuQjtBQUNEOztBQUVELE1BQUloQixNQUFKLEVBQVk7QUFDViw2QkFBZWdCLEVBQWYsRUFBbUJBLEVBQW5CLEVBQXVCLGtCQUFZaEIsTUFBWixFQUFvQmlCLE1BQXBCLEVBQXZCO0FBQ0Q7O0FBRUQsU0FBT0QsRUFBUDtBQUNEOztBQUVEO0FBQ0E7QUFDTyxTQUFTakUsbUJBQVQsU0FNSjtBQUFBLE1BTERtRSxLQUtDLFVBTERBLEtBS0M7QUFBQSxNQUpEZCxNQUlDLFVBSkRBLE1BSUM7QUFBQSxNQUhERyxLQUdDLFVBSERBLEtBR0M7QUFBQSxNQUZERixRQUVDLFVBRkRBLFFBRUM7QUFBQSxxQ0FERGMsY0FDQztBQUFBLE1BRERBLGNBQ0MseUNBRGdCLEVBQ2hCOztBQUFBLDJCQUNxQmIsa0JBQWtCLEVBQUNELGtCQUFELEVBQVdFLFlBQVgsRUFBbEIsQ0FEckI7QUFBQSxNQUNNTSxLQUROLHNCQUNNQSxLQUROO0FBQUEsTUFDYUQsSUFEYixzQkFDYUEsSUFEYjs7QUFFRCxNQUFNUSxNQUFNakIsT0FBTyxFQUFDQyxjQUFELEVBQVNDLGtCQUFULEVBQVAsQ0FBWjs7QUFFQSxNQUFNZ0IsbUJBQW1CLDJCQUN2QixFQUR1QixFQUV2QkQsR0FGdUIsRUFFTDtBQUNsQkYsVUFBUWQsTUFIZSxFQUdMO0FBQ2xCUyxPQUp1QixFQUlMO0FBQ2xCRCxTQUFPTyxjQUxnQixDQUtEO0FBTEMsR0FBekI7O0FBUUEsU0FBT0UsZ0JBQVA7QUFDRDs7QUFFRDs7Ozs7OztBQU9PLFNBQVNyRSxhQUFULENBQXVCc0UsR0FBdkIsRUFBNEJDLHFCQUE1QixFQUFtRDtBQUFBLDRCQUNsQ0QsR0FEa0M7QUFBQSxNQUNqRHJELENBRGlEO0FBQUEsTUFDOUNDLENBRDhDO0FBQUE7QUFBQSxNQUMzQ3NELENBRDJDLHlCQUN2QyxDQUR1Qzs7QUFFeEQsd0JBQU8zQyxTQUFTWixDQUFULEtBQWVZLFNBQVNYLENBQVQsQ0FBZixJQUE4QlcsU0FBUzJDLENBQVQsQ0FBckM7O0FBRUEsU0FBTyxnQ0FBZ0JELHFCQUFoQixFQUF1QyxDQUFDdEQsQ0FBRCxFQUFJQyxDQUFKLEVBQU9zRCxDQUFQLEVBQVUsQ0FBVixDQUF2QyxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNPLFNBQVN2RSxhQUFULENBQXVCcUUsR0FBdkIsRUFBNEJHLHVCQUE1QixFQUFrRTtBQUFBLE1BQWJDLE9BQWEsdUVBQUgsQ0FBRzs7QUFBQSw2QkFDckRKLEdBRHFEO0FBQUEsTUFDaEVyRCxDQURnRTtBQUFBLE1BQzdEQyxDQUQ2RDtBQUFBLE1BQzFEc0QsQ0FEMEQ7O0FBRXZFLHdCQUFPM0MsU0FBU1osQ0FBVCxLQUFlWSxTQUFTWCxDQUFULENBQXRCOztBQUVBLE1BQUl5RCxPQUFPOUMsUUFBUCxDQUFnQjJDLENBQWhCLENBQUosRUFBd0I7QUFDdEI7QUFDQSxRQUFNSSxRQUFRLGdDQUFnQkgsdUJBQWhCLEVBQXlDLENBQUN4RCxDQUFELEVBQUlDLENBQUosRUFBT3NELENBQVAsRUFBVSxDQUFWLENBQXpDLENBQWQ7QUFDQSxXQUFPSSxLQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLE1BQU1DLFNBQVMsZ0NBQWdCSix1QkFBaEIsRUFBeUMsQ0FBQ3hELENBQUQsRUFBSUMsQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBQXpDLENBQWY7QUFDQSxNQUFNNEQsU0FBUyxnQ0FBZ0JMLHVCQUFoQixFQUF5QyxDQUFDeEQsQ0FBRCxFQUFJQyxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FBekMsQ0FBZjs7QUFFQSxNQUFNNkQsS0FBS0YsT0FBTyxDQUFQLENBQVg7QUFDQSxNQUFNRyxLQUFLRixPQUFPLENBQVAsQ0FBWDs7QUFFQSxNQUFNRyxJQUFJRixPQUFPQyxFQUFQLEdBQVksQ0FBWixHQUFnQixDQUFDLENBQUNOLFdBQVcsQ0FBWixJQUFpQkssRUFBbEIsS0FBeUJDLEtBQUtELEVBQTlCLENBQTFCO0FBQ0EsU0FBTyxvQkFBVSxFQUFWLEVBQWNGLE1BQWQsRUFBc0JDLE1BQXRCLEVBQThCRyxDQUE5QixDQUFQO0FBQ0QiLCJmaWxlIjoid2ViLW1lcmNhdG9yLXV0aWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETyAtIFRIRSBVVElMSVRJRVMgSU4gVEhJUyBGSUxFIFNIT1VMRCBCRSBJTVBPUlRFRCBGUk9NIFdFQi1NRVJDQVRPUi1WSUVXUE9SVCBNT0RVTEVcblxuaW1wb3J0IHtWZWN0b3IzfSBmcm9tICdtYXRoLmdsJztcbmltcG9ydCB7Y3JlYXRlTWF0NCwgdHJhbnNmb3JtVmVjdG9yfSBmcm9tICcuL21hdGgtdXRpbHMnO1xuXG5pbXBvcnQgbWF0NF9wZXJzcGVjdGl2ZSBmcm9tICdnbC1tYXQ0L3BlcnNwZWN0aXZlJztcbmltcG9ydCBtYXQ0X3NjYWxlIGZyb20gJ2dsLW1hdDQvc2NhbGUnO1xuaW1wb3J0IG1hdDRfdHJhbnNsYXRlIGZyb20gJ2dsLW1hdDQvdHJhbnNsYXRlJztcbmltcG9ydCBtYXQ0X3JvdGF0ZVggZnJvbSAnZ2wtbWF0NC9yb3RhdGVYJztcbmltcG9ydCBtYXQ0X3JvdGF0ZVogZnJvbSAnZ2wtbWF0NC9yb3RhdGVaJztcbmltcG9ydCB2ZWMyX2xlcnAgZnJvbSAnZ2wtdmVjMi9sZXJwJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuLy8gQ09OU1RBTlRTXG5jb25zdCBQSSA9IE1hdGguUEk7XG5jb25zdCBQSV80ID0gUEkgLyA0O1xuY29uc3QgREVHUkVFU19UT19SQURJQU5TID0gUEkgLyAxODA7XG5jb25zdCBSQURJQU5TX1RPX0RFR1JFRVMgPSAxODAgLyBQSTtcbmNvbnN0IFRJTEVfU0laRSA9IDUxMjtcbi8vIEF2ZXJhZ2UgY2lyY3VtZmVyZW5jZSAoNDAwNzUga20gZXF1YXRvcmlhbCwgNDAwMDcga20gbWVyaWRpb25hbClcbmNvbnN0IEVBUlRIX0NJUkNVTUZFUkVOQ0UgPSA0MC4wM2U2O1xuXG4vKiogVXRpbCBmdW5jdGlvbnMgKiovXG5leHBvcnQgZnVuY3Rpb24gem9vbVRvU2NhbGUoem9vbSkge1xuICByZXR1cm4gTWF0aC5wb3coMiwgem9vbSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZVRvWm9vbShzY2FsZSkge1xuICByZXR1cm4gTWF0aC5sb2cyKHNjYWxlKTtcbn1cblxuLyoqXG4gKiBQcm9qZWN0IFtsbmcsbGF0XSBvbiBzcGhlcmUgb250byBbeCx5XSBvbiA1MTIqNTEyIE1lcmNhdG9yIFpvb20gMCB0aWxlLlxuICogUGVyZm9ybXMgdGhlIG5vbmxpbmVhciBwYXJ0IG9mIHRoZSB3ZWIgbWVyY2F0b3IgcHJvamVjdGlvbi5cbiAqIFJlbWFpbmluZyBwcm9qZWN0aW9uIGlzIGRvbmUgd2l0aCA0eDQgbWF0cmljZXMgd2hpY2ggYWxzbyBoYW5kbGVzXG4gKiBwZXJzcGVjdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBsbmdMYXQgLSBbbG5nLCBsYXRdIGNvb3JkaW5hdGVzXG4gKiAgIFNwZWNpZmllcyBhIHBvaW50IG9uIHRoZSBzcGhlcmUgdG8gcHJvamVjdCBvbnRvIHRoZSBtYXAuXG4gKiBAcmV0dXJuIHtBcnJheX0gW3gseV0gY29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsbmdMYXRUb1dvcmxkKFtsbmcsIGxhdF0sIHNjYWxlKSB7XG4gIHNjYWxlICo9IFRJTEVfU0laRTtcbiAgY29uc3QgbGFtYmRhMiA9IGxuZyAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgY29uc3QgcGhpMiA9IGxhdCAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgY29uc3QgeCA9IHNjYWxlICogKGxhbWJkYTIgKyBQSSkgLyAoMiAqIFBJKTtcbiAgY29uc3QgeSA9IHNjYWxlICogKFBJIC0gTWF0aC5sb2coTWF0aC50YW4oUElfNCArIHBoaTIgKiAwLjUpKSkgLyAoMiAqIFBJKTtcbiAgcmV0dXJuIFt4LCB5XTtcbn1cblxuLyoqXG4gKiBVbnByb2plY3Qgd29ybGQgcG9pbnQgW3gseV0gb24gbWFwIG9udG8ge2xhdCwgbG9ufSBvbiBzcGhlcmVcbiAqXG4gKiBAcGFyYW0ge29iamVjdHxWZWN0b3J9IHh5IC0gb2JqZWN0IHdpdGgge3gseX0gbWVtYmVyc1xuICogIHJlcHJlc2VudGluZyBwb2ludCBvbiBwcm9qZWN0ZWQgbWFwIHBsYW5lXG4gKiBAcmV0dXJuIHtHZW9Db29yZGluYXRlc30gLSBvYmplY3Qgd2l0aCB7bGF0LGxvbn0gb2YgcG9pbnQgb24gc3BoZXJlLlxuICogICBIYXMgdG9BcnJheSBtZXRob2QgaWYgeW91IG5lZWQgYSBHZW9KU09OIEFycmF5LlxuICogICBQZXIgY2FydG9ncmFwaGljIHRyYWRpdGlvbiwgbGF0IGFuZCBsb24gYXJlIHNwZWNpZmllZCBhcyBkZWdyZWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd29ybGRUb0xuZ0xhdChbeCwgeV0sIHNjYWxlKSB7XG4gIHNjYWxlICo9IFRJTEVfU0laRTtcbiAgY29uc3QgbGFtYmRhMiA9ICh4IC8gc2NhbGUpICogKDIgKiBQSSkgLSBQSTtcbiAgY29uc3QgcGhpMiA9IDIgKiAoTWF0aC5hdGFuKE1hdGguZXhwKFBJIC0gKHkgLyBzY2FsZSkgKiAoMiAqIFBJKSkpIC0gUElfNCk7XG4gIHJldHVybiBbbGFtYmRhMiAqIFJBRElBTlNfVE9fREVHUkVFUywgcGhpMiAqIFJBRElBTlNfVE9fREVHUkVFU107XG59XG5cbi8vIFJldHVybnMgdGhlIHpvb20gbGV2ZWwgdGhhdCBnaXZlcyBhIDEgbWV0ZXIgcGl4ZWwgYXQgYSBjZXJ0YWluIGxhdGl0dWRlXG4vLyBTPUMqY29zKHkpLzJeKHorOClcbmV4cG9ydCBmdW5jdGlvbiBnZXRNZXRlclpvb20oe2xhdGl0dWRlfSkge1xuICBhc3NlcnQobGF0aXR1ZGUpO1xuICBjb25zdCBsYXRDb3NpbmUgPSBNYXRoLmNvcyhsYXRpdHVkZSAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG4gIHJldHVybiBzY2FsZVRvWm9vbShFQVJUSF9DSVJDVU1GRVJFTkNFICogbGF0Q29zaW5lKSAtIDg7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGRpc3RhbmNlIHNjYWxlcyBpbiBtZXRlcnMgYXJvdW5kIGN1cnJlbnQgbGF0L2xvbiwgYm90aCBmb3JcbiAqIGRlZ3JlZXMgYW5kIHBpeGVscy5cbiAqIEluIG1lcmNhdG9yIHByb2plY3Rpb24gbW9kZSwgdGhlIGRpc3RhbmNlIHNjYWxlcyB2YXJ5IHNpZ25pZmljYW50bHlcbiAqIHdpdGggbGF0aXR1ZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXN0YW5jZVNjYWxlcyh7bGF0aXR1ZGUsIGxvbmdpdHVkZSwgem9vbSwgc2NhbGUsIGhpZ2hQcmVjaXNpb24gPSBmYWxzZX0pIHtcbiAgLy8gQ2FsY3VsYXRlIHNjYWxlIGZyb20gem9vbSBpZiBub3QgcHJvdmlkZWRcbiAgc2NhbGUgPSBzY2FsZSAhPT0gdW5kZWZpbmVkID8gc2NhbGUgOiB6b29tVG9TY2FsZSh6b29tKTtcblxuICBhc3NlcnQoaXNGaW5pdGUobGF0aXR1ZGUpICYmIGlzRmluaXRlKGxvbmdpdHVkZSkgJiYgaXNGaW5pdGUoc2NhbGUpKTtcblxuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3Qgd29ybGRTaXplID0gVElMRV9TSVpFICogc2NhbGU7XG4gIGNvbnN0IGxhdENvc2luZSA9IE1hdGguY29zKGxhdGl0dWRlICogREVHUkVFU19UT19SQURJQU5TKTtcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHBpeGVscyBvY2N1cGllZCBieSBvbmUgZGVncmVlIGxvbmdpdHVkZSBhcm91bmQgY3VycmVudCBsYXQvbG9uOlxuICAgICBwaXhlbHNQZXJEZWdyZWVYID0gZChsbmdMYXRUb1dvcmxkKFtsbmcsIGxhdF0pWzBdKS9kKGxuZylcbiAgICAgICA9IHNjYWxlICogVElMRV9TSVpFICogREVHUkVFU19UT19SQURJQU5TIC8gKDIgKiBQSSlcbiAgICAgcGl4ZWxzUGVyRGVncmVlWSA9IGQobG5nTGF0VG9Xb3JsZChbbG5nLCBsYXRdKVsxXSkvZChsYXQpXG4gICAgICAgPSAtc2NhbGUgKiBUSUxFX1NJWkUgKiBERUdSRUVTX1RPX1JBRElBTlMgLyBjb3MobGF0ICogREVHUkVFU19UT19SQURJQU5TKSAgLyAoMiAqIFBJKVxuICAgKi9cbiAgY29uc3QgcGl4ZWxzUGVyRGVncmVlWCA9IHdvcmxkU2l6ZSAvIDM2MDtcbiAgY29uc3QgcGl4ZWxzUGVyRGVncmVlWSA9IHBpeGVsc1BlckRlZ3JlZVggLyBsYXRDb3NpbmU7XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBwaXhlbHMgb2NjdXBpZWQgYnkgb25lIG1ldGVyIGFyb3VuZCBjdXJyZW50IGxhdC9sb246XG4gICAqL1xuICBjb25zdCBhbHRQaXhlbHNQZXJNZXRlciA9IHdvcmxkU2l6ZSAvIEVBUlRIX0NJUkNVTUZFUkVOQ0UgLyBsYXRDb3NpbmU7XG5cbiAgcmVzdWx0LnBpeGVsc1Blck1ldGVyID0gW2FsdFBpeGVsc1Blck1ldGVyLCBhbHRQaXhlbHNQZXJNZXRlciwgYWx0UGl4ZWxzUGVyTWV0ZXJdO1xuICByZXN1bHQubWV0ZXJzUGVyUGl4ZWwgPSBbMSAvIGFsdFBpeGVsc1Blck1ldGVyLCAxIC8gYWx0UGl4ZWxzUGVyTWV0ZXIsIDEgLyBhbHRQaXhlbHNQZXJNZXRlcl07XG5cbiAgcmVzdWx0LnBpeGVsc1BlckRlZ3JlZSA9IFtwaXhlbHNQZXJEZWdyZWVYLCBwaXhlbHNQZXJEZWdyZWVZLCBhbHRQaXhlbHNQZXJNZXRlcl07XG4gIHJlc3VsdC5kZWdyZWVzUGVyUGl4ZWwgPSBbMSAvIHBpeGVsc1BlckRlZ3JlZVgsIDEgLyBwaXhlbHNQZXJEZWdyZWVZLCAxIC8gYWx0UGl4ZWxzUGVyTWV0ZXJdO1xuXG4gIC8qKlxuICAgKiBUYXlsb3Igc2VyaWVzIDJuZCBvcmRlciBmb3IgMS9sYXRDb3NpbmVcbiAgICAgZicoYSkgKiAoeCAtIGEpXG4gICAgICAgPSBkKDEvY29zKGxhdCAqIERFR1JFRVNfVE9fUkFESUFOUykpL2QobGF0KSAqIGRMYXRcbiAgICAgICA9IERFR1JFRVNfVE9fUkFESUFOUyAqIHRhbihsYXQgKiBERUdSRUVTX1RPX1JBRElBTlMpIC8gY29zKGxhdCAqIERFR1JFRVNfVE9fUkFESUFOUykgKiBkTGF0XG4gICAqL1xuICBpZiAoaGlnaFByZWNpc2lvbikge1xuICAgIGNvbnN0IGxhdENvc2luZTIgPSBERUdSRUVTX1RPX1JBRElBTlMgKiBNYXRoLnRhbihsYXRpdHVkZSAqIERFR1JFRVNfVE9fUkFESUFOUykgLyBsYXRDb3NpbmU7XG4gICAgY29uc3QgcGl4ZWxzUGVyRGVncmVlWTIgPSBwaXhlbHNQZXJEZWdyZWVYICogbGF0Q29zaW5lMiAvIDI7XG4gICAgY29uc3QgYWx0UGl4ZWxzUGVyRGVncmVlMiA9IHdvcmxkU2l6ZSAvIEVBUlRIX0NJUkNVTUZFUkVOQ0UgKiBsYXRDb3NpbmUyO1xuICAgIGNvbnN0IGFsdFBpeGVsc1Blck1ldGVyMiA9IGFsdFBpeGVsc1BlckRlZ3JlZTIgLyBwaXhlbHNQZXJEZWdyZWVZICogYWx0UGl4ZWxzUGVyTWV0ZXI7XG5cbiAgICByZXN1bHQucGl4ZWxzUGVyRGVncmVlMiA9IFswLCBwaXhlbHNQZXJEZWdyZWVZMiwgYWx0UGl4ZWxzUGVyRGVncmVlMl07XG4gICAgcmVzdWx0LnBpeGVsc1Blck1ldGVyMiA9IFthbHRQaXhlbHNQZXJNZXRlcjIsIDAsIGFsdFBpeGVsc1Blck1ldGVyMl07XG4gIH1cblxuICAvLyBNYWluIHJlc3VsdHMsIHVzZWQgZm9yIGNvbnZlcnRpbmcgbWV0ZXJzIHRvIGxhdGxuZyBkZWx0YXMgYW5kIHNjYWxpbmcgb2Zmc2V0c1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgYSBtZXJjYXRvciB3b3JsZCBwb3NpdGlvbiAoXCJwaXhlbHNcIiBpbiBnaXZlbiB6b29tIGxldmVsKVxuICogZnJvbSBhIGxuZy9sYXQgYW5kIG1ldGVyT2Zmc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRXb3JsZFBvc2l0aW9uKHtcbiAgbG9uZ2l0dWRlLFxuICBsYXRpdHVkZSxcbiAgem9vbSxcbiAgc2NhbGUsXG4gIG1ldGVyT2Zmc2V0LFxuICBkaXN0YW5jZVNjYWxlcyA9IG51bGxcbn0pIHtcbiAgLy8gQ2FsY3VsYXRlIHNjYWxlIGZyb20gem9vbSBpZiBub3QgcHJvdmlkZWRcbiAgc2NhbGUgPSBzY2FsZSAhPT0gdW5kZWZpbmVkID8gc2NhbGUgOiB6b29tVG9TY2FsZSh6b29tKTtcblxuICAvLyBNYWtlIGEgY2VudGVyZWQgdmVyc2lvbiBvZiB0aGUgbWF0cml4IGZvciBwcm9qZWN0aW9uIG1vZGVzIHdpdGhvdXQgYW4gb2Zmc2V0XG4gIGNvbnN0IGNlbnRlcjJkID0gbG5nTGF0VG9Xb3JsZChbbG9uZ2l0dWRlLCBsYXRpdHVkZV0sIHNjYWxlKTtcbiAgY29uc3QgY2VudGVyID0gbmV3IFZlY3RvcjMoY2VudGVyMmRbMF0sIGNlbnRlcjJkWzFdLCAwKTtcblxuICBpZiAobWV0ZXJPZmZzZXQpIHtcbiAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2Ugc2NhbGVzIGlmIGxuZy9sYXQvem9vbSBhcmUgcHJvdmlkZWRcbiAgICBkaXN0YW5jZVNjYWxlcyA9IGRpc3RhbmNlU2NhbGVzIHx8IGdldERpc3RhbmNlU2NhbGVzKHtsYXRpdHVkZSwgbG9uZ2l0dWRlLCBzY2FsZX0pO1xuXG4gICAgY29uc3QgcGl4ZWxQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKG1ldGVyT2Zmc2V0KVxuICAgICAgLy8gQ29udmVydCB0byBwaXhlbHMgaW4gY3VycmVudCB6b29tXG4gICAgICAuc2NhbGUoZGlzdGFuY2VTY2FsZXMucGl4ZWxzUGVyTWV0ZXIpXG4gICAgICAvLyBXZSB3YW50IHBvc2l0aXZlIFkgdG8gcmVwcmVzZW50IGFuIG9mZnNldCB0b3dhcmRzIG5vcnRoLFxuICAgICAgLy8gYnV0IHdlYiBtZXJjYXRvciB3b3JsZCBjb29yZGluYXRlcyBpcyB0b3AtbGVmdFxuICAgICAgLnNjYWxlKFsxLCAtMSwgMV0pO1xuICAgIGNlbnRlci5hZGQocGl4ZWxQb3NpdGlvbik7XG4gIH1cblxuICByZXR1cm4gY2VudGVyO1xufVxuXG4vLyBBVFRSSUJVVElPTjpcbi8vIHZpZXcgYW5kIHByb2plY3Rpb24gbWF0cml4IGNyZWF0aW9uIGlzIGludGVudGlvbmFsbHkga2VwdCBjb21wYXRpYmxlIHdpdGhcbi8vIG1hcGJveC1nbCdzIGltcGxlbWVudGF0aW9uIHRvIGVuc3VyZSB0aGF0IHNlYW1sZXNzIGludGVyb3BlcmF0aW9uXG4vLyB3aXRoIG1hcGJveCBhbmQgcmVhY3QtbWFwLWdsLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzXG5cbi8vIFZhcmlhYmxlIGZvdiAoaW4gcmFkaWFucylcbmZ1bmN0aW9uIGdldEZvdih7aGVpZ2h0LCBhbHRpdHVkZX0pIHtcbiAgcmV0dXJuIDIgKiBNYXRoLmF0YW4oKGhlaWdodCAvIDIpIC8gYWx0aXR1ZGUpO1xufVxuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1BsYW5lcyh7YWx0aXR1ZGUsIHBpdGNofSkge1xuICAvLyBGaW5kIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgcG9pbnQgdG8gdGhlIGNlbnRlciB0b3BcbiAgLy8gaW4gYWx0aXR1ZGUgdW5pdHMgdXNpbmcgbGF3IG9mIHNpbmVzLlxuICBjb25zdCBwaXRjaFJhZGlhbnMgPSBwaXRjaCAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgY29uc3QgaGFsZkZvdiA9IE1hdGguYXRhbigwLjUgLyBhbHRpdHVkZSk7XG4gIGNvbnN0IHRvcEhhbGZTdXJmYWNlRGlzdGFuY2UgPVxuICAgIE1hdGguc2luKGhhbGZGb3YpICogYWx0aXR1ZGUgLyBNYXRoLnNpbihNYXRoLlBJIC8gMiAtIHBpdGNoUmFkaWFucyAtIGhhbGZGb3YpO1xuXG4gIC8vIENhbGN1bGF0ZSB6IHZhbHVlIG9mIHRoZSBmYXJ0aGVzdCBmcmFnbWVudCB0aGF0IHNob3VsZCBiZSByZW5kZXJlZC5cbiAgY29uc3QgZmFyWiA9IE1hdGguY29zKE1hdGguUEkgLyAyIC0gcGl0Y2hSYWRpYW5zKSAqIHRvcEhhbGZTdXJmYWNlRGlzdGFuY2UgKyBhbHRpdHVkZTtcblxuICByZXR1cm4ge2ZhclosIG5lYXJaOiAwLjF9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Vmlld01hdHJpeCh7XG4gIC8vIFZpZXdwb3J0IHByb3BzXG4gIGhlaWdodCxcbiAgcGl0Y2gsXG4gIGJlYXJpbmcsXG4gIGFsdGl0dWRlLFxuICAvLyBQcmUtY2FsY3VsYXRlZCBwYXJhbWV0ZXJzXG4gIGNlbnRlciA9IG51bGwsXG4gIC8vIE9wdGlvbnNcbiAgZmxpcFkgPSBmYWxzZVxufSkge1xuXG4gIC8vIFZJRVcgTUFUUklYOiBQUk9KRUNUUyBNRVJDQVRPUiBXT1JMRCBDT09SRElOQVRFU1xuICAvLyBOb3RlIHRoYXQgbWVyY2F0b3Igd29ybGQgY29vcmRpbmF0ZXMgdHlwaWNhbGx5IG5lZWQgdG8gYmUgZmxpcHBlZFxuICAvL1xuICAvLyBOb3RlOiBBcyB1c3VhbCwgbWF0cml4IG9wZXJhdGlvbiBvcmRlcnMgc2hvdWxkIGJlIHJlYWQgaW4gcmV2ZXJzZVxuICAvLyBzaW5jZSB2ZWN0b3JzIHdpbGwgYmUgbXVsdGlwbGllZCBmcm9tIHRoZSByaWdodCBkdXJpbmcgdHJhbnNmb3JtYXRpb25cbiAgY29uc3Qgdm0gPSBjcmVhdGVNYXQ0KCk7XG5cbiAgLy8gTW92ZSBjYW1lcmEgdG8gYWx0aXR1ZGUgKGFsb25nIHRoZSBwaXRjaCAmIGJlYXJpbmcgZGlyZWN0aW9uKVxuICBtYXQ0X3RyYW5zbGF0ZSh2bSwgdm0sIFswLCAwLCAtYWx0aXR1ZGVdKTtcblxuICAvLyBBZnRlciB0aGUgcm90YXRlWCwgeiB2YWx1ZXMgYXJlIGluIHBpeGVsIHVuaXRzLiBDb252ZXJ0IHRoZW0gdG9cbiAgLy8gYWx0aXR1ZGUgdW5pdHMuIDEgYWx0aXR1ZGUgdW5pdCA9IHRoZSBzY3JlZW4gaGVpZ2h0LlxuICBtYXQ0X3NjYWxlKHZtLCB2bSwgWzEsIDEsIDEgLyBoZWlnaHRdKTtcblxuICAvLyBSb3RhdGUgYnkgYmVhcmluZywgYW5kIHRoZW4gYnkgcGl0Y2ggKHdoaWNoIHRpbHRzIHRoZSB2aWV3KVxuICBtYXQ0X3JvdGF0ZVgodm0sIHZtLCAtcGl0Y2ggKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICBtYXQ0X3JvdGF0ZVoodm0sIHZtLCBiZWFyaW5nICogREVHUkVFU19UT19SQURJQU5TKTtcblxuICBpZiAoZmxpcFkpIHtcbiAgICBtYXQ0X3NjYWxlKHZtLCB2bSwgWzEsIC0xLCAxXSk7XG4gIH1cblxuICBpZiAoY2VudGVyKSB7XG4gICAgbWF0NF90cmFuc2xhdGUodm0sIHZtLCBuZXcgVmVjdG9yMyhjZW50ZXIpLm5lZ2F0ZSgpKTtcbiAgfVxuXG4gIHJldHVybiB2bTtcbn1cblxuLy8gUFJPSkVDVElPTiBNQVRSSVg6IFBST0pFQ1RTIEZST00gQ0FNRVJBIChWSUVXKSBTUEFDRSBUTyBDTElQU1BBQ0Vcbi8vIFRoaXMgaXMgYSBcIk1hcGJveFwiIHByb2plY3Rpb24gbWF0cml4IC0gbWF0Y2hlcyBtYXBib3ggZXhhY3RseSBpZiBmYXJaTXVsdGlwbGllciA9PT0gMVxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb2plY3Rpb25NYXRyaXgoe1xuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBwaXRjaCxcbiAgYWx0aXR1ZGUsXG4gIGZhclpNdWx0aXBsaWVyID0gMTBcbn0pIHtcbiAgY29uc3Qge25lYXJaLCBmYXJafSA9IGdldENsaXBwaW5nUGxhbmVzKHthbHRpdHVkZSwgcGl0Y2h9KTtcbiAgY29uc3QgZm92ID0gZ2V0Rm92KHtoZWlnaHQsIGFsdGl0dWRlfSk7XG5cbiAgY29uc3QgcHJvamVjdGlvbk1hdHJpeCA9IG1hdDRfcGVyc3BlY3RpdmUoXG4gICAgW10sXG4gICAgZm92LCAgICAgICAgICAgICAgLy8gZm92IGluIHJhZGlhbnNcbiAgICB3aWR0aCAvIGhlaWdodCwgICAvLyBhc3BlY3QgcmF0aW9cbiAgICBuZWFyWiwgICAgICAgICAgICAvLyBuZWFyIHBsYW5lXG4gICAgZmFyWiAqIGZhclpNdWx0aXBsaWVyIC8vIGZhciBwbGFuZVxuICApO1xuXG4gIHJldHVybiBwcm9qZWN0aW9uTWF0cml4O1xufVxuXG4vKipcbiAqIFByb2plY3QgZmxhdCBjb29yZGluYXRlcyB0byBwaXhlbHMgb24gc2NyZWVuLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHh5eiAtIGZsYXQgY29vcmRpbmF0ZSBvbiA1MTIqNTEyIE1lcmNhdG9yIFpvb20gMCB0aWxlXG4gKiBAcGFyYW0ge01hdHJpeDR9IHBpeGVsUHJvamVjdGlvbk1hdHJpeCAtIHByb2plY3Rpb24gbWF0cml4XG4gKiBAcmV0dXJuIHtBcnJheX0gW3gsIHksIGRlcHRoXSBwaXhlbCBjb29yZGluYXRlIG9uIHNjcmVlbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdvcmxkVG9QaXhlbHMoeHl6LCBwaXhlbFByb2plY3Rpb25NYXRyaXgpIHtcbiAgY29uc3QgW3gsIHksIHogPSAwXSA9IHh5ejtcbiAgYXNzZXJ0KGlzRmluaXRlKHgpICYmIGlzRmluaXRlKHkpICYmIGlzRmluaXRlKHopKTtcblxuICByZXR1cm4gdHJhbnNmb3JtVmVjdG9yKHBpeGVsUHJvamVjdGlvbk1hdHJpeCwgW3gsIHksIHosIDFdKTtcbn1cblxuLyoqXG4gKiBVbnByb2plY3QgcGl4ZWxzIG9uIHNjcmVlbiB0byBmbGF0IGNvb3JkaW5hdGVzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHh5eiAtIHBpeGVsIGNvb3JkaW5hdGUgb24gc2NyZWVuLlxuICogQHBhcmFtIHtNYXRyaXg0fSBwaXhlbFVucHJvamVjdGlvbk1hdHJpeCAtIHVucHJvamVjdGlvbiBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSB0YXJnZXRaIC0gaWYgcGl4ZWwgY29vcmRpbmF0ZSBkb2VzIG5vdCBoYXZlIGEgM3JkIGNvbXBvbmVudCAoZGVwdGgpLFxuICogICAgdGFyZ2V0WiBpcyB1c2VkIGFzIHRoZSBlbGV2YXRpb24gcGxhbmUgdG8gdW5wcm9qZWN0IG9udG9cbiAqIEByZXR1cm4ge0FycmF5fSBbeCwgeSwgWl0gZmxhdCBjb29yZGluYXRlcyBvbiA1MTIqNTEyIE1lcmNhdG9yIFpvb20gMCB0aWxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGl4ZWxzVG9Xb3JsZCh4eXosIHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCB0YXJnZXRaID0gMCkge1xuICBjb25zdCBbeCwgeSwgel0gPSB4eXo7XG4gIGFzc2VydChpc0Zpbml0ZSh4KSAmJiBpc0Zpbml0ZSh5KSk7XG5cbiAgaWYgKE51bWJlci5pc0Zpbml0ZSh6KSkge1xuICAgIC8vIEhhcyBkZXB0aCBjb21wb25lbnRcbiAgICBjb25zdCBjb29yZCA9IHRyYW5zZm9ybVZlY3RvcihwaXhlbFVucHJvamVjdGlvbk1hdHJpeCwgW3gsIHksIHosIDFdKTtcbiAgICByZXR1cm4gY29vcmQ7XG4gIH1cblxuICAvLyBzaW5jZSB3ZSBkb24ndCBrbm93IHRoZSBjb3JyZWN0IHByb2plY3RlZCB6IHZhbHVlIGZvciB0aGUgcG9pbnQsXG4gIC8vIHVucHJvamVjdCB0d28gcG9pbnRzIHRvIGdldCBhIGxpbmUgYW5kIHRoZW4gZmluZCB0aGUgcG9pbnQgb24gdGhhdCBsaW5lIHdpdGggej0wXG4gIGNvbnN0IGNvb3JkMCA9IHRyYW5zZm9ybVZlY3RvcihwaXhlbFVucHJvamVjdGlvbk1hdHJpeCwgW3gsIHksIDAsIDFdKTtcbiAgY29uc3QgY29vcmQxID0gdHJhbnNmb3JtVmVjdG9yKHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCBbeCwgeSwgMSwgMV0pO1xuXG4gIGNvbnN0IHowID0gY29vcmQwWzJdO1xuICBjb25zdCB6MSA9IGNvb3JkMVsyXTtcblxuICBjb25zdCB0ID0gejAgPT09IHoxID8gMCA6ICgodGFyZ2V0WiB8fCAwKSAtIHowKSAvICh6MSAtIHowKTtcbiAgcmV0dXJuIHZlYzJfbGVycChbXSwgY29vcmQwLCBjb29yZDEsIHQpO1xufVxuIl19