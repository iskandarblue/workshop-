var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

// TODO - THE UTILITIES IN THIS FILE SHOULD BE IMPORTED FROM WEB-MERCATOR-VIEWPORT MODULE

import { Vector3 } from 'math.gl';
import { createMat4, transformVector } from './math-utils';

import mat4_perspective from 'gl-mat4/perspective';
import mat4_scale from 'gl-mat4/scale';
import mat4_translate from 'gl-mat4/translate';
import mat4_rotateX from 'gl-mat4/rotateX';
import mat4_rotateZ from 'gl-mat4/rotateZ';
import vec2_lerp from 'gl-vec2/lerp';
import assert from 'assert';

// CONSTANTS
var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS = PI / 180;
var RADIANS_TO_DEGREES = 180 / PI;
var TILE_SIZE = 512;
// Average circumference (40075 km equatorial, 40007 km meridional)
var EARTH_CIRCUMFERENCE = 40.03e6;

/** Util functions **/
export function zoomToScale(zoom) {
  return Math.pow(2, zoom);
}

export function scaleToZoom(scale) {
  return Math.log2(scale);
}

/**
 * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
 * Performs the nonlinear part of the web mercator projection.
 * Remaining projection is done with 4x4 matrices which also handles
 * perspective.
 *
 * @param {Array} lngLat - [lng, lat] coordinates
 *   Specifies a point on the sphere to project onto the map.
 * @return {Array} [x,y] coordinates.
 */
export function lngLatToWorld(_ref, scale) {
  var _ref2 = _slicedToArray(_ref, 2),
      lng = _ref2[0],
      lat = _ref2[1];

  scale *= TILE_SIZE;
  var lambda2 = lng * DEGREES_TO_RADIANS;
  var phi2 = lat * DEGREES_TO_RADIANS;
  var x = scale * (lambda2 + PI) / (2 * PI);
  var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x, y];
}

/**
 * Unproject world point [x,y] on map onto {lat, lon} on sphere
 *
 * @param {object|Vector} xy - object with {x,y} members
 *  representing point on projected map plane
 * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
 *   Has toArray method if you need a GeoJSON Array.
 *   Per cartographic tradition, lat and lon are specified as degrees.
 */
export function worldToLngLat(_ref3, scale) {
  var _ref4 = _slicedToArray(_ref3, 2),
      x = _ref4[0],
      y = _ref4[1];

  scale *= TILE_SIZE;
  var lambda2 = x / scale * (2 * PI) - PI;
  var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale * (2 * PI))) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
}

// Returns the zoom level that gives a 1 meter pixel at a certain latitude
// S=C*cos(y)/2^(z+8)
export function getMeterZoom(_ref5) {
  var latitude = _ref5.latitude;

  assert(latitude);
  var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
  return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 8;
}

/**
 * Calculate distance scales in meters around current lat/lon, both for
 * degrees and pixels.
 * In mercator projection mode, the distance scales vary significantly
 * with latitude.
 */
export function getDistanceScales(_ref6) {
  var latitude = _ref6.latitude,
      longitude = _ref6.longitude,
      zoom = _ref6.zoom,
      scale = _ref6.scale,
      _ref6$highPrecision = _ref6.highPrecision,
      highPrecision = _ref6$highPrecision === undefined ? false : _ref6$highPrecision;

  // Calculate scale from zoom if not provided
  scale = scale !== undefined ? scale : zoomToScale(zoom);

  assert(isFinite(latitude) && isFinite(longitude) && isFinite(scale));

  var result = {};
  var worldSize = TILE_SIZE * scale;
  var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);

  /**
   * Number of pixels occupied by one degree longitude around current lat/lon:
     pixelsPerDegreeX = d(lngLatToWorld([lng, lat])[0])/d(lng)
       = scale * TILE_SIZE * DEGREES_TO_RADIANS / (2 * PI)
     pixelsPerDegreeY = d(lngLatToWorld([lng, lat])[1])/d(lat)
       = -scale * TILE_SIZE * DEGREES_TO_RADIANS / cos(lat * DEGREES_TO_RADIANS)  / (2 * PI)
   */
  var pixelsPerDegreeX = worldSize / 360;
  var pixelsPerDegreeY = pixelsPerDegreeX / latCosine;

  /**
   * Number of pixels occupied by one meter around current lat/lon:
   */
  var altPixelsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;

  result.pixelsPerMeter = [altPixelsPerMeter, altPixelsPerMeter, altPixelsPerMeter];
  result.metersPerPixel = [1 / altPixelsPerMeter, 1 / altPixelsPerMeter, 1 / altPixelsPerMeter];

  result.pixelsPerDegree = [pixelsPerDegreeX, pixelsPerDegreeY, altPixelsPerMeter];
  result.degreesPerPixel = [1 / pixelsPerDegreeX, 1 / pixelsPerDegreeY, 1 / altPixelsPerMeter];

  /**
   * Taylor series 2nd order for 1/latCosine
     f'(a) * (x - a)
       = d(1/cos(lat * DEGREES_TO_RADIANS))/d(lat) * dLat
       = DEGREES_TO_RADIANS * tan(lat * DEGREES_TO_RADIANS) / cos(lat * DEGREES_TO_RADIANS) * dLat
   */
  if (highPrecision) {
    var latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;
    var pixelsPerDegreeY2 = pixelsPerDegreeX * latCosine2 / 2;
    var altPixelsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
    var altPixelsPerMeter2 = altPixelsPerDegree2 / pixelsPerDegreeY * altPixelsPerMeter;

    result.pixelsPerDegree2 = [0, pixelsPerDegreeY2, altPixelsPerDegree2];
    result.pixelsPerMeter2 = [altPixelsPerMeter2, 0, altPixelsPerMeter2];
  }

  // Main results, used for converting meters to latlng deltas and scaling offsets
  return result;
}

/**
 * Calculates a mercator world position ("pixels" in given zoom level)
 * from a lng/lat and meterOffset
 */
export function getWorldPosition(_ref7) {
  var longitude = _ref7.longitude,
      latitude = _ref7.latitude,
      zoom = _ref7.zoom,
      scale = _ref7.scale,
      meterOffset = _ref7.meterOffset,
      _ref7$distanceScales = _ref7.distanceScales,
      distanceScales = _ref7$distanceScales === undefined ? null : _ref7$distanceScales;

  // Calculate scale from zoom if not provided
  scale = scale !== undefined ? scale : zoomToScale(zoom);

  // Make a centered version of the matrix for projection modes without an offset
  var center2d = lngLatToWorld([longitude, latitude], scale);
  var center = new Vector3(center2d[0], center2d[1], 0);

  if (meterOffset) {
    // Calculate distance scales if lng/lat/zoom are provided
    distanceScales = distanceScales || getDistanceScales({ latitude: latitude, longitude: longitude, scale: scale });

    var pixelPosition = new Vector3(meterOffset)
    // Convert to pixels in current zoom
    .scale(distanceScales.pixelsPerMeter)
    // We want positive Y to represent an offset towards north,
    // but web mercator world coordinates is top-left
    .scale([1, -1, 1]);
    center.add(pixelPosition);
  }

  return center;
}

// ATTRIBUTION:
// view and projection matrix creation is intentionally kept compatible with
// mapbox-gl's implementation to ensure that seamless interoperation
// with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js

// Variable fov (in radians)
function getFov(_ref8) {
  var height = _ref8.height,
      altitude = _ref8.altitude;

  return 2 * Math.atan(height / 2 / altitude);
}

function getClippingPlanes(_ref9) {
  var altitude = _ref9.altitude,
      pitch = _ref9.pitch;

  // Find the distance from the center point to the center top
  // in altitude units using law of sines.
  var pitchRadians = pitch * DEGREES_TO_RADIANS;
  var halfFov = Math.atan(0.5 / altitude);
  var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov);

  // Calculate z value of the farthest fragment that should be rendered.
  var farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;

  return { farZ: farZ, nearZ: 0.1 };
}

export function getViewMatrix(_ref10) {
  var height = _ref10.height,
      pitch = _ref10.pitch,
      bearing = _ref10.bearing,
      altitude = _ref10.altitude,
      _ref10$center = _ref10.center,
      center = _ref10$center === undefined ? null : _ref10$center,
      _ref10$flipY = _ref10.flipY,
      flipY = _ref10$flipY === undefined ? false : _ref10$flipY;


  // VIEW MATRIX: PROJECTS MERCATOR WORLD COORDINATES
  // Note that mercator world coordinates typically need to be flipped
  //
  // Note: As usual, matrix operation orders should be read in reverse
  // since vectors will be multiplied from the right during transformation
  var vm = createMat4();

  // Move camera to altitude (along the pitch & bearing direction)
  mat4_translate(vm, vm, [0, 0, -altitude]);

  // After the rotateX, z values are in pixel units. Convert them to
  // altitude units. 1 altitude unit = the screen height.
  mat4_scale(vm, vm, [1, 1, 1 / height]);

  // Rotate by bearing, and then by pitch (which tilts the view)
  mat4_rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS);
  mat4_rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS);

  if (flipY) {
    mat4_scale(vm, vm, [1, -1, 1]);
  }

  if (center) {
    mat4_translate(vm, vm, new Vector3(center).negate());
  }

  return vm;
}

// PROJECTION MATRIX: PROJECTS FROM CAMERA (VIEW) SPACE TO CLIPSPACE
// This is a "Mapbox" projection matrix - matches mapbox exactly if farZMultiplier === 1
export function getProjectionMatrix(_ref11) {
  var width = _ref11.width,
      height = _ref11.height,
      pitch = _ref11.pitch,
      altitude = _ref11.altitude,
      _ref11$farZMultiplier = _ref11.farZMultiplier,
      farZMultiplier = _ref11$farZMultiplier === undefined ? 10 : _ref11$farZMultiplier;

  var _getClippingPlanes = getClippingPlanes({ altitude: altitude, pitch: pitch }),
      nearZ = _getClippingPlanes.nearZ,
      farZ = _getClippingPlanes.farZ;

  var fov = getFov({ height: height, altitude: altitude });

  var projectionMatrix = mat4_perspective([], fov, // fov in radians
  width / height, // aspect ratio
  nearZ, // near plane
  farZ * farZMultiplier // far plane
  );

  return projectionMatrix;
}

/**
 * Project flat coordinates to pixels on screen.
 *
 * @param {Array} xyz - flat coordinate on 512*512 Mercator Zoom 0 tile
 * @param {Matrix4} pixelProjectionMatrix - projection matrix
 * @return {Array} [x, y, depth] pixel coordinate on screen.
 */
export function worldToPixels(xyz, pixelProjectionMatrix) {
  var _xyz = _slicedToArray(xyz, 3),
      x = _xyz[0],
      y = _xyz[1],
      _xyz$ = _xyz[2],
      z = _xyz$ === undefined ? 0 : _xyz$;

  assert(isFinite(x) && isFinite(y) && isFinite(z));

  return transformVector(pixelProjectionMatrix, [x, y, z, 1]);
}

/**
 * Unproject pixels on screen to flat coordinates.
 *
 * @param {Array} xyz - pixel coordinate on screen.
 * @param {Matrix4} pixelUnprojectionMatrix - unprojection matrix
 * @param {Number} targetZ - if pixel coordinate does not have a 3rd component (depth),
 *    targetZ is used as the elevation plane to unproject onto
 * @return {Array} [x, y, Z] flat coordinates on 512*512 Mercator Zoom 0 tile.
 */
export function pixelsToWorld(xyz, pixelUnprojectionMatrix) {
  var targetZ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  var _xyz2 = _slicedToArray(xyz, 3),
      x = _xyz2[0],
      y = _xyz2[1],
      z = _xyz2[2];

  assert(isFinite(x) && isFinite(y));

  if (Number.isFinite(z)) {
    // Has depth component
    var coord = transformVector(pixelUnprojectionMatrix, [x, y, z, 1]);
    return coord;
  }

  // since we don't know the correct projected z value for the point,
  // unproject two points to get a line and then find the point on that line with z=0
  var coord0 = transformVector(pixelUnprojectionMatrix, [x, y, 0, 1]);
  var coord1 = transformVector(pixelUnprojectionMatrix, [x, y, 1, 1]);

  var z0 = coord0[2];
  var z1 = coord1[2];

  var t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
  return vec2_lerp([], coord0, coord1, t);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy93ZWItbWVyY2F0b3ItdXRpbHMuanMiXSwibmFtZXMiOlsiVmVjdG9yMyIsImNyZWF0ZU1hdDQiLCJ0cmFuc2Zvcm1WZWN0b3IiLCJtYXQ0X3BlcnNwZWN0aXZlIiwibWF0NF9zY2FsZSIsIm1hdDRfdHJhbnNsYXRlIiwibWF0NF9yb3RhdGVYIiwibWF0NF9yb3RhdGVaIiwidmVjMl9sZXJwIiwiYXNzZXJ0IiwiUEkiLCJNYXRoIiwiUElfNCIsIkRFR1JFRVNfVE9fUkFESUFOUyIsIlJBRElBTlNfVE9fREVHUkVFUyIsIlRJTEVfU0laRSIsIkVBUlRIX0NJUkNVTUZFUkVOQ0UiLCJ6b29tVG9TY2FsZSIsInpvb20iLCJwb3ciLCJzY2FsZVRvWm9vbSIsInNjYWxlIiwibG9nMiIsImxuZ0xhdFRvV29ybGQiLCJsbmciLCJsYXQiLCJsYW1iZGEyIiwicGhpMiIsIngiLCJ5IiwibG9nIiwidGFuIiwid29ybGRUb0xuZ0xhdCIsImF0YW4iLCJleHAiLCJnZXRNZXRlclpvb20iLCJsYXRpdHVkZSIsImxhdENvc2luZSIsImNvcyIsImdldERpc3RhbmNlU2NhbGVzIiwibG9uZ2l0dWRlIiwiaGlnaFByZWNpc2lvbiIsInVuZGVmaW5lZCIsImlzRmluaXRlIiwicmVzdWx0Iiwid29ybGRTaXplIiwicGl4ZWxzUGVyRGVncmVlWCIsInBpeGVsc1BlckRlZ3JlZVkiLCJhbHRQaXhlbHNQZXJNZXRlciIsInBpeGVsc1Blck1ldGVyIiwibWV0ZXJzUGVyUGl4ZWwiLCJwaXhlbHNQZXJEZWdyZWUiLCJkZWdyZWVzUGVyUGl4ZWwiLCJsYXRDb3NpbmUyIiwicGl4ZWxzUGVyRGVncmVlWTIiLCJhbHRQaXhlbHNQZXJEZWdyZWUyIiwiYWx0UGl4ZWxzUGVyTWV0ZXIyIiwicGl4ZWxzUGVyRGVncmVlMiIsInBpeGVsc1Blck1ldGVyMiIsImdldFdvcmxkUG9zaXRpb24iLCJtZXRlck9mZnNldCIsImRpc3RhbmNlU2NhbGVzIiwiY2VudGVyMmQiLCJjZW50ZXIiLCJwaXhlbFBvc2l0aW9uIiwiYWRkIiwiZ2V0Rm92IiwiaGVpZ2h0IiwiYWx0aXR1ZGUiLCJnZXRDbGlwcGluZ1BsYW5lcyIsInBpdGNoIiwicGl0Y2hSYWRpYW5zIiwiaGFsZkZvdiIsInRvcEhhbGZTdXJmYWNlRGlzdGFuY2UiLCJzaW4iLCJmYXJaIiwibmVhcloiLCJnZXRWaWV3TWF0cml4IiwiYmVhcmluZyIsImZsaXBZIiwidm0iLCJuZWdhdGUiLCJnZXRQcm9qZWN0aW9uTWF0cml4Iiwid2lkdGgiLCJmYXJaTXVsdGlwbGllciIsImZvdiIsInByb2plY3Rpb25NYXRyaXgiLCJ3b3JsZFRvUGl4ZWxzIiwieHl6IiwicGl4ZWxQcm9qZWN0aW9uTWF0cml4IiwieiIsInBpeGVsc1RvV29ybGQiLCJwaXhlbFVucHJvamVjdGlvbk1hdHJpeCIsInRhcmdldFoiLCJOdW1iZXIiLCJjb29yZCIsImNvb3JkMCIsImNvb3JkMSIsInowIiwiejEiLCJ0Il0sIm1hcHBpbmdzIjoiOztBQUFBOztBQUVBLFNBQVFBLE9BQVIsUUFBc0IsU0FBdEI7QUFDQSxTQUFRQyxVQUFSLEVBQW9CQyxlQUFwQixRQUEwQyxjQUExQzs7QUFFQSxPQUFPQyxnQkFBUCxNQUE2QixxQkFBN0I7QUFDQSxPQUFPQyxVQUFQLE1BQXVCLGVBQXZCO0FBQ0EsT0FBT0MsY0FBUCxNQUEyQixtQkFBM0I7QUFDQSxPQUFPQyxZQUFQLE1BQXlCLGlCQUF6QjtBQUNBLE9BQU9DLFlBQVAsTUFBeUIsaUJBQXpCO0FBQ0EsT0FBT0MsU0FBUCxNQUFzQixjQUF0QjtBQUNBLE9BQU9DLE1BQVAsTUFBbUIsUUFBbkI7O0FBRUE7QUFDQSxJQUFNQyxLQUFLQyxLQUFLRCxFQUFoQjtBQUNBLElBQU1FLE9BQU9GLEtBQUssQ0FBbEI7QUFDQSxJQUFNRyxxQkFBcUJILEtBQUssR0FBaEM7QUFDQSxJQUFNSSxxQkFBcUIsTUFBTUosRUFBakM7QUFDQSxJQUFNSyxZQUFZLEdBQWxCO0FBQ0E7QUFDQSxJQUFNQyxzQkFBc0IsT0FBNUI7O0FBRUE7QUFDQSxPQUFP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QUFWLEVBQWN3RixNQUFkLEVBQXNCQyxNQUF0QixFQUE4QkcsQ0FBOUIsQ0FBUDtBQUNEIiwiZmlsZSI6IndlYi1tZXJjYXRvci11dGlscy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRPRE8gLSBUSEUgVVRJTElUSUVTIElOIFRISVMgRklMRSBTSE9VTEQgQkUgSU1QT1JURUQgRlJPTSBXRUItTUVSQ0FUT1ItVklFV1BPUlQgTU9EVUxFXG5cbmltcG9ydCB7VmVjdG9yM30gZnJvbSAnbWF0aC5nbCc7XG5pbXBvcnQge2NyZWF0ZU1hdDQsIHRyYW5zZm9ybVZlY3Rvcn0gZnJvbSAnLi9tYXRoLXV0aWxzJztcblxuaW1wb3J0IG1hdDRfcGVyc3BlY3RpdmUgZnJvbSAnZ2wtbWF0NC9wZXJzcGVjdGl2ZSc7XG5pbXBvcnQgbWF0NF9zY2FsZSBmcm9tICdnbC1tYXQ0L3NjYWxlJztcbmltcG9ydCBtYXQ0X3RyYW5zbGF0ZSBmcm9tICdnbC1tYXQ0L3RyYW5zbGF0ZSc7XG5pbXBvcnQgbWF0NF9yb3RhdGVYIGZyb20gJ2dsLW1hdDQvcm90YXRlWCc7XG5pbXBvcnQgbWF0NF9yb3RhdGVaIGZyb20gJ2dsLW1hdDQvcm90YXRlWic7XG5pbXBvcnQgdmVjMl9sZXJwIGZyb20gJ2dsLXZlYzIvbGVycCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbi8vIENPTlNUQU5UU1xuY29uc3QgUEkgPSBNYXRoLlBJO1xuY29uc3QgUElfNCA9IFBJIC8gNDtcbmNvbnN0IERFR1JFRVNfVE9fUkFESUFOUyA9IFBJIC8gMTgwO1xuY29uc3QgUkFESUFOU19UT19ERUdSRUVTID0gMTgwIC8gUEk7XG5jb25zdCBUSUxFX1NJWkUgPSA1MTI7XG4vLyBBdmVyYWdlIGNpcmN1bWZlcmVuY2UgKDQwMDc1IGttIGVxdWF0b3JpYWwsIDQwMDA3IGttIG1lcmlkaW9uYWwpXG5jb25zdCBFQVJUSF9DSVJDVU1GRVJFTkNFID0gNDAuMDNlNjtcblxuLyoqIFV0aWwgZnVuY3Rpb25zICoqL1xuZXhwb3J0IGZ1bmN0aW9uIHpvb21Ub1NjYWxlKHpvb20pIHtcbiAgcmV0dXJuIE1hdGgucG93KDIsIHpvb20pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVUb1pvb20oc2NhbGUpIHtcbiAgcmV0dXJuIE1hdGgubG9nMihzY2FsZSk7XG59XG5cbi8qKlxuICogUHJvamVjdCBbbG5nLGxhdF0gb24gc3BoZXJlIG9udG8gW3gseV0gb24gNTEyKjUxMiBNZXJjYXRvciBab29tIDAgdGlsZS5cbiAqIFBlcmZvcm1zIHRoZSBub25saW5lYXIgcGFydCBvZiB0aGUgd2ViIG1lcmNhdG9yIHByb2plY3Rpb24uXG4gKiBSZW1haW5pbmcgcHJvamVjdGlvbiBpcyBkb25lIHdpdGggNHg0IG1hdHJpY2VzIHdoaWNoIGFsc28gaGFuZGxlc1xuICogcGVyc3BlY3RpdmUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbG5nTGF0IC0gW2xuZywgbGF0XSBjb29yZGluYXRlc1xuICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc3BoZXJlIHRvIHByb2plY3Qgb250byB0aGUgbWFwLlxuICogQHJldHVybiB7QXJyYXl9IFt4LHldIGNvb3JkaW5hdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbG5nTGF0VG9Xb3JsZChbbG5nLCBsYXRdLCBzY2FsZSkge1xuICBzY2FsZSAqPSBUSUxFX1NJWkU7XG4gIGNvbnN0IGxhbWJkYTIgPSBsbmcgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IHBoaTIgPSBsYXQgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IHggPSBzY2FsZSAqIChsYW1iZGEyICsgUEkpIC8gKDIgKiBQSSk7XG4gIGNvbnN0IHkgPSBzY2FsZSAqIChQSSAtIE1hdGgubG9nKE1hdGgudGFuKFBJXzQgKyBwaGkyICogMC41KSkpIC8gKDIgKiBQSSk7XG4gIHJldHVybiBbeCwgeV07XG59XG5cbi8qKlxuICogVW5wcm9qZWN0IHdvcmxkIHBvaW50IFt4LHldIG9uIG1hcCBvbnRvIHtsYXQsIGxvbn0gb24gc3BoZXJlXG4gKlxuICogQHBhcmFtIHtvYmplY3R8VmVjdG9yfSB4eSAtIG9iamVjdCB3aXRoIHt4LHl9IG1lbWJlcnNcbiAqICByZXByZXNlbnRpbmcgcG9pbnQgb24gcHJvamVjdGVkIG1hcCBwbGFuZVxuICogQHJldHVybiB7R2VvQ29vcmRpbmF0ZXN9IC0gb2JqZWN0IHdpdGgge2xhdCxsb259IG9mIHBvaW50IG9uIHNwaGVyZS5cbiAqICAgSGFzIHRvQXJyYXkgbWV0aG9kIGlmIHlvdSBuZWVkIGEgR2VvSlNPTiBBcnJheS5cbiAqICAgUGVyIGNhcnRvZ3JhcGhpYyB0cmFkaXRpb24sIGxhdCBhbmQgbG9uIGFyZSBzcGVjaWZpZWQgYXMgZGVncmVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdvcmxkVG9MbmdMYXQoW3gsIHldLCBzY2FsZSkge1xuICBzY2FsZSAqPSBUSUxFX1NJWkU7XG4gIGNvbnN0IGxhbWJkYTIgPSAoeCAvIHNjYWxlKSAqICgyICogUEkpIC0gUEk7XG4gIGNvbnN0IHBoaTIgPSAyICogKE1hdGguYXRhbihNYXRoLmV4cChQSSAtICh5IC8gc2NhbGUpICogKDIgKiBQSSkpKSAtIFBJXzQpO1xuICByZXR1cm4gW2xhbWJkYTIgKiBSQURJQU5TX1RPX0RFR1JFRVMsIHBoaTIgKiBSQURJQU5TX1RPX0RFR1JFRVNdO1xufVxuXG4vLyBSZXR1cm5zIHRoZSB6b29tIGxldmVsIHRoYXQgZ2l2ZXMgYSAxIG1ldGVyIHBpeGVsIGF0IGEgY2VydGFpbiBsYXRpdHVkZVxuLy8gUz1DKmNvcyh5KS8yXih6KzgpXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWV0ZXJab29tKHtsYXRpdHVkZX0pIHtcbiAgYXNzZXJ0KGxhdGl0dWRlKTtcbiAgY29uc3QgbGF0Q29zaW5lID0gTWF0aC5jb3MobGF0aXR1ZGUgKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICByZXR1cm4gc2NhbGVUb1pvb20oRUFSVEhfQ0lSQ1VNRkVSRU5DRSAqIGxhdENvc2luZSkgLSA4O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBkaXN0YW5jZSBzY2FsZXMgaW4gbWV0ZXJzIGFyb3VuZCBjdXJyZW50IGxhdC9sb24sIGJvdGggZm9yXG4gKiBkZWdyZWVzIGFuZCBwaXhlbHMuXG4gKiBJbiBtZXJjYXRvciBwcm9qZWN0aW9uIG1vZGUsIHRoZSBkaXN0YW5jZSBzY2FsZXMgdmFyeSBzaWduaWZpY2FudGx5XG4gKiB3aXRoIGxhdGl0dWRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzdGFuY2VTY2FsZXMoe2xhdGl0dWRlLCBsb25naXR1ZGUsIHpvb20sIHNjYWxlLCBoaWdoUHJlY2lzaW9uID0gZmFsc2V9KSB7XG4gIC8vIENhbGN1bGF0ZSBzY2FsZSBmcm9tIHpvb20gaWYgbm90IHByb3ZpZGVkXG4gIHNjYWxlID0gc2NhbGUgIT09IHVuZGVmaW5lZCA/IHNjYWxlIDogem9vbVRvU2NhbGUoem9vbSk7XG5cbiAgYXNzZXJ0KGlzRmluaXRlKGxhdGl0dWRlKSAmJiBpc0Zpbml0ZShsb25naXR1ZGUpICYmIGlzRmluaXRlKHNjYWxlKSk7XG5cbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IHdvcmxkU2l6ZSA9IFRJTEVfU0laRSAqIHNjYWxlO1xuICBjb25zdCBsYXRDb3NpbmUgPSBNYXRoLmNvcyhsYXRpdHVkZSAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBwaXhlbHMgb2NjdXBpZWQgYnkgb25lIGRlZ3JlZSBsb25naXR1ZGUgYXJvdW5kIGN1cnJlbnQgbGF0L2xvbjpcbiAgICAgcGl4ZWxzUGVyRGVncmVlWCA9IGQobG5nTGF0VG9Xb3JsZChbbG5nLCBsYXRdKVswXSkvZChsbmcpXG4gICAgICAgPSBzY2FsZSAqIFRJTEVfU0laRSAqIERFR1JFRVNfVE9fUkFESUFOUyAvICgyICogUEkpXG4gICAgIHBpeGVsc1BlckRlZ3JlZVkgPSBkKGxuZ0xhdFRvV29ybGQoW2xuZywgbGF0XSlbMV0pL2QobGF0KVxuICAgICAgID0gLXNjYWxlICogVElMRV9TSVpFICogREVHUkVFU19UT19SQURJQU5TIC8gY29zKGxhdCAqIERFR1JFRVNfVE9fUkFESUFOUykgIC8gKDIgKiBQSSlcbiAgICovXG4gIGNvbnN0IHBpeGVsc1BlckRlZ3JlZVggPSB3b3JsZFNpemUgLyAzNjA7XG4gIGNvbnN0IHBpeGVsc1BlckRlZ3JlZVkgPSBwaXhlbHNQZXJEZWdyZWVYIC8gbGF0Q29zaW5lO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIG9jY3VwaWVkIGJ5IG9uZSBtZXRlciBhcm91bmQgY3VycmVudCBsYXQvbG9uOlxuICAgKi9cbiAgY29uc3QgYWx0UGl4ZWxzUGVyTWV0ZXIgPSB3b3JsZFNpemUgLyBFQVJUSF9DSVJDVU1GRVJFTkNFIC8gbGF0Q29zaW5lO1xuXG4gIHJlc3VsdC5waXhlbHNQZXJNZXRlciA9IFthbHRQaXhlbHNQZXJNZXRlciwgYWx0UGl4ZWxzUGVyTWV0ZXIsIGFsdFBpeGVsc1Blck1ldGVyXTtcbiAgcmVzdWx0Lm1ldGVyc1BlclBpeGVsID0gWzEgLyBhbHRQaXhlbHNQZXJNZXRlciwgMSAvIGFsdFBpeGVsc1Blck1ldGVyLCAxIC8gYWx0UGl4ZWxzUGVyTWV0ZXJdO1xuXG4gIHJlc3VsdC5waXhlbHNQZXJEZWdyZWUgPSBbcGl4ZWxzUGVyRGVncmVlWCwgcGl4ZWxzUGVyRGVncmVlWSwgYWx0UGl4ZWxzUGVyTWV0ZXJdO1xuICByZXN1bHQuZGVncmVlc1BlclBpeGVsID0gWzEgLyBwaXhlbHNQZXJEZWdyZWVYLCAxIC8gcGl4ZWxzUGVyRGVncmVlWSwgMSAvIGFsdFBpeGVsc1Blck1ldGVyXTtcblxuICAvKipcbiAgICogVGF5bG9yIHNlcmllcyAybmQgb3JkZXIgZm9yIDEvbGF0Q29zaW5lXG4gICAgIGYnKGEpICogKHggLSBhKVxuICAgICAgID0gZCgxL2NvcyhsYXQgKiBERUdSRUVTX1RPX1JBRElBTlMpKS9kKGxhdCkgKiBkTGF0XG4gICAgICAgPSBERUdSRUVTX1RPX1JBRElBTlMgKiB0YW4obGF0ICogREVHUkVFU19UT19SQURJQU5TKSAvIGNvcyhsYXQgKiBERUdSRUVTX1RPX1JBRElBTlMpICogZExhdFxuICAgKi9cbiAgaWYgKGhpZ2hQcmVjaXNpb24pIHtcbiAgICBjb25zdCBsYXRDb3NpbmUyID0gREVHUkVFU19UT19SQURJQU5TICogTWF0aC50YW4obGF0aXR1ZGUgKiBERUdSRUVTX1RPX1JBRElBTlMpIC8gbGF0Q29zaW5lO1xuICAgIGNvbnN0IHBpeGVsc1BlckRlZ3JlZVkyID0gcGl4ZWxzUGVyRGVncmVlWCAqIGxhdENvc2luZTIgLyAyO1xuICAgIGNvbnN0IGFsdFBpeGVsc1BlckRlZ3JlZTIgPSB3b3JsZFNpemUgLyBFQVJUSF9DSVJDVU1GRVJFTkNFICogbGF0Q29zaW5lMjtcbiAgICBjb25zdCBhbHRQaXhlbHNQZXJNZXRlcjIgPSBhbHRQaXhlbHNQZXJEZWdyZWUyIC8gcGl4ZWxzUGVyRGVncmVlWSAqIGFsdFBpeGVsc1Blck1ldGVyO1xuXG4gICAgcmVzdWx0LnBpeGVsc1BlckRlZ3JlZTIgPSBbMCwgcGl4ZWxzUGVyRGVncmVlWTIsIGFsdFBpeGVsc1BlckRlZ3JlZTJdO1xuICAgIHJlc3VsdC5waXhlbHNQZXJNZXRlcjIgPSBbYWx0UGl4ZWxzUGVyTWV0ZXIyLCAwLCBhbHRQaXhlbHNQZXJNZXRlcjJdO1xuICB9XG5cbiAgLy8gTWFpbiByZXN1bHRzLCB1c2VkIGZvciBjb252ZXJ0aW5nIG1ldGVycyB0byBsYXRsbmcgZGVsdGFzIGFuZCBzY2FsaW5nIG9mZnNldHNcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgbWVyY2F0b3Igd29ybGQgcG9zaXRpb24gKFwicGl4ZWxzXCIgaW4gZ2l2ZW4gem9vbSBsZXZlbClcbiAqIGZyb20gYSBsbmcvbGF0IGFuZCBtZXRlck9mZnNldFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0V29ybGRQb3NpdGlvbih7XG4gIGxvbmdpdHVkZSxcbiAgbGF0aXR1ZGUsXG4gIHpvb20sXG4gIHNjYWxlLFxuICBtZXRlck9mZnNldCxcbiAgZGlzdGFuY2VTY2FsZXMgPSBudWxsXG59KSB7XG4gIC8vIENhbGN1bGF0ZSBzY2FsZSBmcm9tIHpvb20gaWYgbm90IHByb3ZpZGVkXG4gIHNjYWxlID0gc2NhbGUgIT09IHVuZGVmaW5lZCA/IHNjYWxlIDogem9vbVRvU2NhbGUoem9vbSk7XG5cbiAgLy8gTWFrZSBhIGNlbnRlcmVkIHZlcnNpb24gb2YgdGhlIG1hdHJpeCBmb3IgcHJvamVjdGlvbiBtb2RlcyB3aXRob3V0IGFuIG9mZnNldFxuICBjb25zdCBjZW50ZXIyZCA9IGxuZ0xhdFRvV29ybGQoW2xvbmdpdHVkZSwgbGF0aXR1ZGVdLCBzY2FsZSk7XG4gIGNvbnN0IGNlbnRlciA9IG5ldyBWZWN0b3IzKGNlbnRlcjJkWzBdLCBjZW50ZXIyZFsxXSwgMCk7XG5cbiAgaWYgKG1ldGVyT2Zmc2V0KSB7XG4gICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIHNjYWxlcyBpZiBsbmcvbGF0L3pvb20gYXJlIHByb3ZpZGVkXG4gICAgZGlzdGFuY2VTY2FsZXMgPSBkaXN0YW5jZVNjYWxlcyB8fCBnZXREaXN0YW5jZVNjYWxlcyh7bGF0aXR1ZGUsIGxvbmdpdHVkZSwgc2NhbGV9KTtcblxuICAgIGNvbnN0IHBpeGVsUG9zaXRpb24gPSBuZXcgVmVjdG9yMyhtZXRlck9mZnNldClcbiAgICAgIC8vIENvbnZlcnQgdG8gcGl4ZWxzIGluIGN1cnJlbnQgem9vbVxuICAgICAgLnNjYWxlKGRpc3RhbmNlU2NhbGVzLnBpeGVsc1Blck1ldGVyKVxuICAgICAgLy8gV2Ugd2FudCBwb3NpdGl2ZSBZIHRvIHJlcHJlc2VudCBhbiBvZmZzZXQgdG93YXJkcyBub3J0aCxcbiAgICAgIC8vIGJ1dCB3ZWIgbWVyY2F0b3Igd29ybGQgY29vcmRpbmF0ZXMgaXMgdG9wLWxlZnRcbiAgICAgIC5zY2FsZShbMSwgLTEsIDFdKTtcbiAgICBjZW50ZXIuYWRkKHBpeGVsUG9zaXRpb24pO1xuICB9XG5cbiAgcmV0dXJuIGNlbnRlcjtcbn1cblxuLy8gQVRUUklCVVRJT046XG4vLyB2aWV3IGFuZCBwcm9qZWN0aW9uIG1hdHJpeCBjcmVhdGlvbiBpcyBpbnRlbnRpb25hbGx5IGtlcHQgY29tcGF0aWJsZSB3aXRoXG4vLyBtYXBib3gtZ2wncyBpbXBsZW1lbnRhdGlvbiB0byBlbnN1cmUgdGhhdCBzZWFtbGVzcyBpbnRlcm9wZXJhdGlvblxuLy8gd2l0aCBtYXBib3ggYW5kIHJlYWN0LW1hcC1nbC4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC1nbC1qc1xuXG4vLyBWYXJpYWJsZSBmb3YgKGluIHJhZGlhbnMpXG5mdW5jdGlvbiBnZXRGb3Yoe2hlaWdodCwgYWx0aXR1ZGV9KSB7XG4gIHJldHVybiAyICogTWF0aC5hdGFuKChoZWlnaHQgLyAyKSAvIGFsdGl0dWRlKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdQbGFuZXMoe2FsdGl0dWRlLCBwaXRjaH0pIHtcbiAgLy8gRmluZCB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIHBvaW50IHRvIHRoZSBjZW50ZXIgdG9wXG4gIC8vIGluIGFsdGl0dWRlIHVuaXRzIHVzaW5nIGxhdyBvZiBzaW5lcy5cbiAgY29uc3QgcGl0Y2hSYWRpYW5zID0gcGl0Y2ggKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IGhhbGZGb3YgPSBNYXRoLmF0YW4oMC41IC8gYWx0aXR1ZGUpO1xuICBjb25zdCB0b3BIYWxmU3VyZmFjZURpc3RhbmNlID1cbiAgICBNYXRoLnNpbihoYWxmRm92KSAqIGFsdGl0dWRlIC8gTWF0aC5zaW4oTWF0aC5QSSAvIDIgLSBwaXRjaFJhZGlhbnMgLSBoYWxmRm92KTtcblxuICAvLyBDYWxjdWxhdGUgeiB2YWx1ZSBvZiB0aGUgZmFydGhlc3QgZnJhZ21lbnQgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gIGNvbnN0IGZhclogPSBNYXRoLmNvcyhNYXRoLlBJIC8gMiAtIHBpdGNoUmFkaWFucykgKiB0b3BIYWxmU3VyZmFjZURpc3RhbmNlICsgYWx0aXR1ZGU7XG5cbiAgcmV0dXJuIHtmYXJaLCBuZWFyWjogMC4xfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZpZXdNYXRyaXgoe1xuICAvLyBWaWV3cG9ydCBwcm9wc1xuICBoZWlnaHQsXG4gIHBpdGNoLFxuICBiZWFyaW5nLFxuICBhbHRpdHVkZSxcbiAgLy8gUHJlLWNhbGN1bGF0ZWQgcGFyYW1ldGVyc1xuICBjZW50ZXIgPSBudWxsLFxuICAvLyBPcHRpb25zXG4gIGZsaXBZID0gZmFsc2Vcbn0pIHtcblxuICAvLyBWSUVXIE1BVFJJWDogUFJPSkVDVFMgTUVSQ0FUT1IgV09STEQgQ09PUkRJTkFURVNcbiAgLy8gTm90ZSB0aGF0IG1lcmNhdG9yIHdvcmxkIGNvb3JkaW5hdGVzIHR5cGljYWxseSBuZWVkIHRvIGJlIGZsaXBwZWRcbiAgLy9cbiAgLy8gTm90ZTogQXMgdXN1YWwsIG1hdHJpeCBvcGVyYXRpb24gb3JkZXJzIHNob3VsZCBiZSByZWFkIGluIHJldmVyc2VcbiAgLy8gc2luY2UgdmVjdG9ycyB3aWxsIGJlIG11bHRpcGxpZWQgZnJvbSB0aGUgcmlnaHQgZHVyaW5nIHRyYW5zZm9ybWF0aW9uXG4gIGNvbnN0IHZtID0gY3JlYXRlTWF0NCgpO1xuXG4gIC8vIE1vdmUgY2FtZXJhIHRvIGFsdGl0dWRlIChhbG9uZyB0aGUgcGl0Y2ggJiBiZWFyaW5nIGRpcmVjdGlvbilcbiAgbWF0NF90cmFuc2xhdGUodm0sIHZtLCBbMCwgMCwgLWFsdGl0dWRlXSk7XG5cbiAgLy8gQWZ0ZXIgdGhlIHJvdGF0ZVgsIHogdmFsdWVzIGFyZSBpbiBwaXhlbCB1bml0cy4gQ29udmVydCB0aGVtIHRvXG4gIC8vIGFsdGl0dWRlIHVuaXRzLiAxIGFsdGl0dWRlIHVuaXQgPSB0aGUgc2NyZWVuIGhlaWdodC5cbiAgbWF0NF9zY2FsZSh2bSwgdm0sIFsxLCAxLCAxIC8gaGVpZ2h0XSk7XG5cbiAgLy8gUm90YXRlIGJ5IGJlYXJpbmcsIGFuZCB0aGVuIGJ5IHBpdGNoICh3aGljaCB0aWx0cyB0aGUgdmlldylcbiAgbWF0NF9yb3RhdGVYKHZtLCB2bSwgLXBpdGNoICogREVHUkVFU19UT19SQURJQU5TKTtcbiAgbWF0NF9yb3RhdGVaKHZtLCB2bSwgYmVhcmluZyAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG5cbiAgaWYgKGZsaXBZKSB7XG4gICAgbWF0NF9zY2FsZSh2bSwgdm0sIFsxLCAtMSwgMV0pO1xuICB9XG5cbiAgaWYgKGNlbnRlcikge1xuICAgIG1hdDRfdHJhbnNsYXRlKHZtLCB2bSwgbmV3IFZlY3RvcjMoY2VudGVyKS5uZWdhdGUoKSk7XG4gIH1cblxuICByZXR1cm4gdm07XG59XG5cbi8vIFBST0pFQ1RJT04gTUFUUklYOiBQUk9KRUNUUyBGUk9NIENBTUVSQSAoVklFVykgU1BBQ0UgVE8gQ0xJUFNQQUNFXG4vLyBUaGlzIGlzIGEgXCJNYXBib3hcIiBwcm9qZWN0aW9uIG1hdHJpeCAtIG1hdGNoZXMgbWFwYm94IGV4YWN0bHkgaWYgZmFyWk11bHRpcGxpZXIgPT09IDFcbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9qZWN0aW9uTWF0cml4KHtcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgcGl0Y2gsXG4gIGFsdGl0dWRlLFxuICBmYXJaTXVsdGlwbGllciA9IDEwXG59KSB7XG4gIGNvbnN0IHtuZWFyWiwgZmFyWn0gPSBnZXRDbGlwcGluZ1BsYW5lcyh7YWx0aXR1ZGUsIHBpdGNofSk7XG4gIGNvbnN0IGZvdiA9IGdldEZvdih7aGVpZ2h0LCBhbHRpdHVkZX0pO1xuXG4gIGNvbnN0IHByb2plY3Rpb25NYXRyaXggPSBtYXQ0X3BlcnNwZWN0aXZlKFxuICAgIFtdLFxuICAgIGZvdiwgICAgICAgICAgICAgIC8vIGZvdiBpbiByYWRpYW5zXG4gICAgd2lkdGggLyBoZWlnaHQsICAgLy8gYXNwZWN0IHJhdGlvXG4gICAgbmVhclosICAgICAgICAgICAgLy8gbmVhciBwbGFuZVxuICAgIGZhclogKiBmYXJaTXVsdGlwbGllciAvLyBmYXIgcGxhbmVcbiAgKTtcblxuICByZXR1cm4gcHJvamVjdGlvbk1hdHJpeDtcbn1cblxuLyoqXG4gKiBQcm9qZWN0IGZsYXQgY29vcmRpbmF0ZXMgdG8gcGl4ZWxzIG9uIHNjcmVlbi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB4eXogLSBmbGF0IGNvb3JkaW5hdGUgb24gNTEyKjUxMiBNZXJjYXRvciBab29tIDAgdGlsZVxuICogQHBhcmFtIHtNYXRyaXg0fSBwaXhlbFByb2plY3Rpb25NYXRyaXggLSBwcm9qZWN0aW9uIG1hdHJpeFxuICogQHJldHVybiB7QXJyYXl9IFt4LCB5LCBkZXB0aF0gcGl4ZWwgY29vcmRpbmF0ZSBvbiBzY3JlZW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3b3JsZFRvUGl4ZWxzKHh5eiwgcGl4ZWxQcm9qZWN0aW9uTWF0cml4KSB7XG4gIGNvbnN0IFt4LCB5LCB6ID0gMF0gPSB4eXo7XG4gIGFzc2VydChpc0Zpbml0ZSh4KSAmJiBpc0Zpbml0ZSh5KSAmJiBpc0Zpbml0ZSh6KSk7XG5cbiAgcmV0dXJuIHRyYW5zZm9ybVZlY3RvcihwaXhlbFByb2plY3Rpb25NYXRyaXgsIFt4LCB5LCB6LCAxXSk7XG59XG5cbi8qKlxuICogVW5wcm9qZWN0IHBpeGVscyBvbiBzY3JlZW4gdG8gZmxhdCBjb29yZGluYXRlcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB4eXogLSBwaXhlbCBjb29yZGluYXRlIG9uIHNjcmVlbi5cbiAqIEBwYXJhbSB7TWF0cml4NH0gcGl4ZWxVbnByb2plY3Rpb25NYXRyaXggLSB1bnByb2plY3Rpb24gbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gdGFyZ2V0WiAtIGlmIHBpeGVsIGNvb3JkaW5hdGUgZG9lcyBub3QgaGF2ZSBhIDNyZCBjb21wb25lbnQgKGRlcHRoKSxcbiAqICAgIHRhcmdldFogaXMgdXNlZCBhcyB0aGUgZWxldmF0aW9uIHBsYW5lIHRvIHVucHJvamVjdCBvbnRvXG4gKiBAcmV0dXJuIHtBcnJheX0gW3gsIHksIFpdIGZsYXQgY29vcmRpbmF0ZXMgb24gNTEyKjUxMiBNZXJjYXRvciBab29tIDAgdGlsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBpeGVsc1RvV29ybGQoeHl6LCBwaXhlbFVucHJvamVjdGlvbk1hdHJpeCwgdGFyZ2V0WiA9IDApIHtcbiAgY29uc3QgW3gsIHksIHpdID0geHl6O1xuICBhc3NlcnQoaXNGaW5pdGUoeCkgJiYgaXNGaW5pdGUoeSkpO1xuXG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoeikpIHtcbiAgICAvLyBIYXMgZGVwdGggY29tcG9uZW50XG4gICAgY29uc3QgY29vcmQgPSB0cmFuc2Zvcm1WZWN0b3IocGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsIFt4LCB5LCB6LCAxXSk7XG4gICAgcmV0dXJuIGNvb3JkO1xuICB9XG5cbiAgLy8gc2luY2Ugd2UgZG9uJ3Qga25vdyB0aGUgY29ycmVjdCBwcm9qZWN0ZWQgeiB2YWx1ZSBmb3IgdGhlIHBvaW50LFxuICAvLyB1bnByb2plY3QgdHdvIHBvaW50cyB0byBnZXQgYSBsaW5lIGFuZCB0aGVuIGZpbmQgdGhlIHBvaW50IG9uIHRoYXQgbGluZSB3aXRoIHo9MFxuICBjb25zdCBjb29yZDAgPSB0cmFuc2Zvcm1WZWN0b3IocGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsIFt4LCB5LCAwLCAxXSk7XG4gIGNvbnN0IGNvb3JkMSA9IHRyYW5zZm9ybVZlY3RvcihwaXhlbFVucHJvamVjdGlvbk1hdHJpeCwgW3gsIHksIDEsIDFdKTtcblxuICBjb25zdCB6MCA9IGNvb3JkMFsyXTtcbiAgY29uc3QgejEgPSBjb29yZDFbMl07XG5cbiAgY29uc3QgdCA9IHowID09PSB6MSA/IDAgOiAoKHRhcmdldFogfHwgMCkgLSB6MCkgLyAoejEgLSB6MCk7XG4gIHJldHVybiB2ZWMyX2xlcnAoW10sIGNvb3JkMCwgY29vcmQxLCB0KTtcbn1cbiJdfQ==